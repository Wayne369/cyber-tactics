<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber_tactics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>

    <style>
        /* ç§»é™¤ overflow: hiddenï¼Œå…è¨±æ‰‹æ©Ÿç¶²é æ•´é«”æ²å‹• */
        body { 
            background-color: #020617; 
            color: white; 
            overflow-y: auto; 
            touch-action: auto; 
            -webkit-overflow-scrolling: touch;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(51, 65, 85, 0.5);
        }
        /* ç¢ºä¿æ²å‹•é †æš¢ */
        .scroll-smooth {
            scroll-behavior: smooth;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Sword, Eye, Castle, Zap, Heart, Shield, Footprints, X, Cpu, Sparkles, ScrollText, Play, RotateCcw, ChevronLeft, User, AlertTriangle, Flame, Plus, Volume2, VolumeX, Skull, Ghost, VenetianMask, Info, Target, Timer } from 'lucide-react';

        // --- Gemini API è¨­å®š ---
        const GEMINI_API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        // --- éŸ³æ•ˆç³»çµ± ---
        const audioCtx = typeof window !== 'undefined' ? new (window.AudioContext || window.webkitAudioContext)() : null;

        const playSound = (type) => {
          if (!audioCtx || audioCtx.state === 'suspended') audioCtx?.resume();
          if (!audioCtx) return;

          const osc = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          osc.connect(gainNode);
          gainNode.connect(audioCtx.destination);

          const now = audioCtx.currentTime;

          switch (type) {
            case 'move':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(300, now);
              osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
              gainNode.gain.setValueAtTime(0.2, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
              osc.start(now);
              osc.stop(now + 0.15);
              break;
            case 'attack':
              osc.type = 'sawtooth';
              osc.frequency.setValueAtTime(150, now);
              osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
              gainNode.gain.setValueAtTime(0.2, now);
              gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;
            case 'stealth':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(1200, now);
              osc.frequency.linearRampToValueAtTime(400, now + 0.4);
              gainNode.gain.setValueAtTime(0, now);
              gainNode.gain.linearRampToValueAtTime(0.1, now + 0.1);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
              osc.start(now);
              osc.stop(now + 0.4);
              break;
            case 'respawn':
              osc.type = 'triangle';
              osc.frequency.setValueAtTime(200, now);
              osc.frequency.linearRampToValueAtTime(800, now + 0.5);
              gainNode.gain.setValueAtTime(0, now);
              gainNode.gain.linearRampToValueAtTime(0.2, now + 0.2);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
              osc.start(now);
              osc.stop(now + 0.5);
              break;
            case 'card':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(880, now);
              osc.frequency.exponentialRampToValueAtTime(1760, now + 0.3);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
              osc.start(now);
              osc.stop(now + 0.3);
              break;
            case 'damage':
              osc.type = 'square';
              osc.frequency.setValueAtTime(80, now);
              gainNode.gain.setValueAtTime(0.3, now);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;
            case 'ui_click':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(1000, now);
              gainNode.gain.setValueAtTime(0.05, now);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.05);
              osc.start(now);
              osc.stop(now + 0.05);
              break;
            case 'ui_cancel':
              osc.type = 'triangle';
              osc.frequency.setValueAtTime(300, now);
              osc.frequency.linearRampToValueAtTime(200, now + 0.1);
              gainNode.gain.setValueAtTime(0.05, now);
              gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
              osc.start(now);
              osc.stop(now + 0.1);
              break;
            case 'error':
              osc.type = 'sawtooth';
              osc.frequency.setValueAtTime(150, now);
              osc.frequency.linearRampToValueAtTime(100, now + 0.2);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.linearRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;
            case 'turn_start':
              osc.type = 'sine';
              osc.frequency.setValueAtTime(523, now);
              osc.frequency.setValueAtTime(659, now + 0.1);
              gainNode.gain.setValueAtTime(0.1, now);
              gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
              osc.start(now);
              osc.stop(now + 0.3);
              break;
            case 'bgm_tick': 
              osc.type = 'sine';
              osc.frequency.setValueAtTime(55, now);
              gainNode.gain.setValueAtTime(0.02, now);
              gainNode.gain.linearRampToValueAtTime(0, now + 2);
              osc.start(now);
              osc.stop(now + 2);
              break;
            default:
              break;
          }
        };

        // --- å¸¸æ•¸è¨­å®š ---
        const RESPAWN_TURNS = 3; 
        const BASE_HP = 10;

        const PLAYERS = [
          { id: 0, name: 'ç´…éšŠ (ç©å®¶)', color: 'bg-red-600', text: 'text-red-500', border: 'border-red-500', baseBg: 'bg-red-900/30', isBot: false },
          { id: 1, name: 'è—éšŠ (é›»è…¦)', color: 'bg-blue-600', text: 'text-blue-500', border: 'border-blue-500', baseBg: 'bg-blue-900/30', isBot: true },
          { id: 2, name: 'ç¶ éšŠ (é›»è…¦)', color: 'bg-emerald-600', text: 'text-emerald-500', border: 'border-emerald-500', baseBg: 'bg-emerald-900/30', isBot: true },
          { id: 3, name: 'é»ƒéšŠ (é›»è…¦)', color: 'bg-amber-500', text: 'text-amber-500', border: 'border-amber-500', baseBg: 'bg-amber-900/30', isBot: true },
        ];

        const UNIT_TYPES = {
          WARRIOR: { name: 'æˆ°å£«', hp: 6, atk: 3, icon: Sword, moveRange: 2 },
          SCOUT: { name: 'åµæŸ¥å…µ', hp: 3, atk: 1, icon: Eye, moveRange: 2 },
          ASSASSIN: { name: 'åˆºå®¢', hp: 4, atk: 2, icon: Ghost, moveRange: 3 },
        };

        const BASE_CARDS = [
          { id: 'heal', name: 'æ€¥æ•‘åŒ…', desc: 'æ¢å¾©å–®ä½ 3 HP', icon: Heart, effect: 'HEAL' },
          { id: 'snipe', name: 'ç‹™æ“Š', desc: 'é ç¨‹ 2 å‚·å®³', icon: Zap, effect: 'DMG' },
          { id: 'shield', name: 'åŸºåœ°è­·ç›¾', desc: 'åŸºåœ° +5 HP', icon: Shield, effect: 'BASE_HEAL' },
          { id: 'berserk', name: 'ç‹‚æš´é‡åŠ‘', desc: 'ä¸‹ä¸€æ¬¡æ”»æ“Šé›™å€å‚·å®³', icon: Flame, effect: 'BUFF_DMG' },
          { id: 'armor', name: 'å‹•åŠ›è£ç”²', desc: 'æŒ‡å®šå–®ä½ç²å¾— 4 é»é¡å¤–è¡€é‡', icon: Plus, effect: 'BUFF_HP' },
        ];

        const ASSASSIN_CARDS = [
            ...BASE_CARDS,
            { id: 'stealth', name: 'éš±å½¢æŠ«é¢¨', desc: 'åˆºå®¢éš±èº«ä¸€å›åˆ (æ•µäººä¸å¯è¦‹)', icon: VenetianMask, effect: 'BUFF_STEALTH' }
        ];

        const getDistance = (p1, p2) => Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        async function callGemini(prompt) {
          try {
            const response = await fetch(GEMINI_API_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });
            if (!response.ok) return null;
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
          } catch (error) { return null; }
        }

        function App() {
          const [view, setView] = useState('MENU');
          const [gameMode, setGameMode] = useState('STANDARD'); 
          const [gridSize, setGridSize] = useState(8);
          const [turn, setTurn] = useState(0);
          const [round, setRound] = useState(1);
          const [players, setPlayers] = useState(PLAYERS.map(p => ({ ...p, isAlive: true, cards: [] })));
          const [units, setUnits] = useState([]);
          const [deadUnits, setDeadUnits] = useState([]); 
          const [bases, setBases] = useState([]);
          const [items, setItems] = useState([]);
          const [logs, setLogs] = useState([]);
          const [gameOver, setGameOver] = useState(false);
          const [audioEnabled, setAudioEnabled] = useState(true);

          const [selectedUnitId, setSelectedUnitId] = useState(null);
          const [validMoves, setValidMoves] = useState([]);
          const [validTargets, setValidTargets] = useState([]);
          const [isAttacking, setIsAttacking] = useState(false);
          const [selectedCard, setSelectedCard] = useState(null);
          const [isBotThinking, setIsBotThinking] = useState(false);
          const [aiAdvice, setAiAdvice] = useState(null);
          const [isAiAdvising, setIsAiAdvising] = useState(false);

          const currentPlayer = players[turn];
          const selectedUnit = units.find(u => u.id === selectedUnitId);

          const gameStateRef = useRef({ units, bases, items, players, gameOver, deadUnits, round, gridSize });

          useEffect(() => {
            gameStateRef.current = { units, bases, items, players, gameOver, deadUnits, round, gridSize };
          }, [units, bases, items, players, gameOver, deadUnits, round, gridSize]);

          useEffect(() => {
            if (view === 'GAME' && !gameOver && players[turn].isBot) {
              runBotTurn();
            }
          }, [turn, gameOver, view]);

          useEffect(() => {
            let interval;
            if (view === 'GAME' && audioEnabled && !gameOver) {
               interval = setInterval(() => { if(Math.random() > 0.5) playSound('bgm_tick'); }, 3000);
            }
            return () => clearInterval(interval);
          }, [view, audioEnabled, gameOver]);

          const initGame = (mode) => {
            setGameMode(mode);
            const size = mode === 'ASSASSIN' ? 10 : 8;
            setGridSize(size);

            const newBases = [
              { id: 0, owner: 0, x: 0, y: 0, hp: BASE_HP },
              { id: 1, owner: 1, x: size - 1, y: 0, hp: BASE_HP },
              { id: 2, owner: 2, x: 0, y: size - 1, hp: BASE_HP },
              { id: 3, owner: 3, x: size - 1, y: size - 1, hp: BASE_HP },
            ];

            let newUnits = [
              { id: 'r_w', owner: 0, type: 'WARRIOR', x: 1, y: 0, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'r_s', owner: 0, type: 'SCOUT', x: 0, y: 1, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'b_w', owner: 1, type: 'WARRIOR', x: size - 2, y: 0, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'b_s', owner: 1, type: 'SCOUT', x: size - 1, y: 1, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'g_w', owner: 2, type: 'WARRIOR', x: 1, y: size - 1, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'g_s', owner: 2, type: 'SCOUT', x: 0, y: size - 2, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'y_w', owner: 3, type: 'WARRIOR', x: size - 2, y: size - 1, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'y_s', owner: 3, type: 'SCOUT', x: size - 1, y: size - 2, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
            ];

            if (mode === 'ASSASSIN') {
                newUnits.push(
                    { id: 'r_a', owner: 0, type: 'ASSASSIN', x: 1, y: 1, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'b_a', owner: 1, type: 'ASSASSIN', x: size - 2, y: 1, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'g_a', owner: 2, type: 'ASSASSIN', x: 1, y: size - 2, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'y_a', owner: 3, type: 'ASSASSIN', x: size - 2, y: size - 2, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} }
                );
            }

            const deck = mode === 'ASSASSIN' ? ASSASSIN_CARDS : BASE_CARDS;
            const initialPlayers = PLAYERS.map(p => {
                const hand = [];
                for(let i=0; i<3; i++) hand.push(deck[Math.floor(Math.random() * deck.length)]);
                return { ...p, isAlive: true, cards: hand };
            });

            setBases(newBases);
            setUnits(newUnits);
            setItems([{ x: Math.floor(size/2), y: Math.floor(size/2), type: 'CARD' }, { x: Math.floor(size/2)-1, y: Math.floor(size/2)-1, type: 'CARD' }]);
            setLogs([{ text: mode === 'ASSASSIN' ? 'åˆºå®¢æ¨¡å¼å•Ÿå‹•ï¼å…¨è»å‡ºæ“Šï¼' : 'æ¨™æº–æˆ°å½¹é–‹å§‹ï¼', type: 'system' }]);
            setPlayers(initialPlayers);
            setDeadUnits([]);
            setTurn(0);
            setRound(1);
            setGameOver(false);
            setAiAdvice(null);
            setValidMoves([]);
            setSelectedUnitId(null);
            setView('GAME');
            if(audioEnabled) playSound('turn_start');
          };

          const quitGame = () => { setView('MENU'); setIsBotThinking(false); if(audioEnabled) playSound('ui_cancel'); };
          const addLog = (msg, type = 'system') => { setLogs(prev => [{ text: msg, type }, ...prev].slice(8)); };

          const updateGameState = (updates) => {
            if (updates.units) setUnits(updates.units);
            if (updates.players) setPlayers(updates.players);
            if (updates.bases) setBases(updates.bases);
            if (updates.items) setItems(updates.items);
            if (updates.deadUnits) setDeadUnits(updates.deadUnits);
            if (updates.gameOver !== undefined) setGameOver(updates.gameOver);
            gameStateRef.current = { ...gameStateRef.current, ...updates };
          };

          const checkRespawns = (currentPlayerId) => {
              const { deadUnits: currentDead, round: currentRound, gridSize: size } = gameStateRef.current;
              const toRespawn = currentDead.filter(d => d.owner === currentPlayerId && d.respawnRound <= currentRound);
              const stillDead = currentDead.filter(d => !(d.owner === currentPlayerId && d.respawnRound <= currentRound));
              if (toRespawn.length === 0) return;

              let currentUnits = [...gameStateRef.current.units];
              const base = gameStateRef.current.bases.find(b => b.owner === currentPlayerId);

              toRespawn.forEach(d => {
                  let spawnPos = { x: base.x, y: base.y };
                  const isOccupied = (tx, ty) => currentUnits.some(u => u.x === tx && u.y === ty);
                  if (isOccupied(base.x, base.y)) {
                      const adjacents = [{x:base.x+1,y:base.y},{x:base.x-1,y:base.y},{x:base.x,y:base.y+1},{x:base.x,y:base.y-1}]
                                        .filter(p => p.x >=0 && p.x < size && p.y >=0 && p.y < size);
                      const freeSpot = adjacents.find(p => !isOccupied(p.x, p.y));
                      if (freeSpot) spawnPos = freeSpot;
                      else return; 
                  }
                  const newUnit = { id: `${currentPlayerId}_${d.type}_${Date.now()}_${Math.random()}`, owner: currentPlayerId, type: d.type, x: spawnPos.x, y: spawnPos.y, hp: UNIT_TYPES[d.type].hp, hasActed: false, buffs: {} };
                  currentUnits.push(newUnit);
                  addLog(`${PLAYERS[currentPlayerId].name} çš„ ${UNIT_TYPES[d.type].name} å¾©æ´»ã€‚`, 'system');
                  if(audioEnabled) playSound('respawn');
              });
              updateGameState({ units: currentUnits, deadUnits: stillDead });
          };

          const handleUnitDeath = (unitId, unitType, ownerId) => {
             const respawnRound = gameStateRef.current.round + RESPAWN_TURNS;
             const newDead = [...gameStateRef.current.deadUnits, { type: unitType, owner: ownerId, respawnRound }];
             const newUnits = gameStateRef.current.units.filter(u => u.id !== unitId);
             updateGameState({ units: newUnits, deadUnits: newDead });
          };

          const performMove = async (unitId, x, y) => {
             const unit = gameStateRef.current.units.find(u => u.id === unitId);
             if (!unit) return;
             if(audioEnabled) playSound('move');
             let newUnits = gameStateRef.current.units.map(u => u.id === unitId ? { ...u, x, y, hasActed: true } : u);
             let stateUpdates = { units: newUnits };
             const itemIndex = gameStateRef.current.items.findIndex(i => i.x === x && i.y === y);
             if (itemIndex !== -1 && unit.type === 'SCOUT') {
                 const deck = gameMode === 'ASSASSIN' ? ASSASSIN_CARDS : BASE_CARDS;
                 const randomCard = deck[Math.floor(Math.random() * deck.length)];
                 const newPlayers = [...gameStateRef.current.players];
                 newPlayers[unit.owner].cards.push(randomCard);
                 const newItems = [...gameStateRef.current.items];
                 newItems.splice(itemIndex, 1);
                 addLog(`${PLAYERS[unit.owner].name} ç²å–äº† ${randomCard.name}`);
                 if(audioEnabled) playSound('card');
                 stateUpdates.players = newPlayers;
                 stateUpdates.items = newItems;
             }
             updateGameState(stateUpdates);
          };

          const performAttack = async (attackerId, targetId, targetType) => {
              const attackerUnit = gameStateRef.current.units.find(u => u.id === attackerId);
              if (!attackerUnit || attackerUnit.hasActed) return;
              let dmg = UNIT_TYPES[attackerUnit.type].atk;
              if (attackerUnit.buffs?.doubleDamage) dmg *= 2;
              if(audioEnabled) playSound('attack');
              let stateUpdates = {};
              if (targetType === 'UNIT') {
                  const targetUnit = gameStateRef.current.units.find(u => u.id === targetId);
                  if(!targetUnit) return;
                  const newHp = targetUnit.hp - dmg;
                  if(audioEnabled) playSound('damage');
                  let newUnits = gameStateRef.current.units.map(u => u.id === targetId ? { ...u, hp: newHp } : u);
                  addLog(`${PLAYERS[attackerUnit.owner].name} æ”»æ“Š ${PLAYERS[targetUnit.owner].name} é€ æˆ ${dmg} å‚·å®³`);
                  if (newHp <= 0) {
                      addLog('æ“Šç ´ç›®æ¨™å–®ä½ï¼');
                      handleUnitDeath(targetId, targetUnit.type, targetUnit.owner);
                      newUnits = gameStateRef.current.units; 
                  }
                  newUnits = newUnits.map(u => u.id === attackerId ? { ...u, hasActed: true, buffs: { ...u.buffs, doubleDamage: false, stealth: false } } : u);
                  stateUpdates.units = newUnits;
              } else if (targetType === 'BASE') {
                  const targetBase = gameStateRef.current.bases.find(b => b.id === targetId);
                  const newHp = targetBase.hp - dmg;
                  const newBases = gameStateRef.current.bases.map(b => b.id === targetId ? { ...b, hp: newHp } : b);
                  let newUnits = gameStateRef.current.units.map(u => u.id === attackerId ? { ...u, hasActed: true, buffs: { ...u.buffs, doubleDamage: false, stealth: false } } : u);
                  stateUpdates.units = newUnits;
                  stateUpdates.bases = newBases;
                  addLog(`æ”»æ“Šå¤§æœ¬ç‡Ÿï¼å‰©é¤˜ HP ${Math.max(0, newHp)}`);
                  if(audioEnabled) playSound('damage');
                  if (newHp <= 0) { updateGameState(stateUpdates); handlePlayerDefeat(targetBase.owner); return; }
              }
              updateGameState(stateUpdates);
          };

          const handlePlayerDefeat = (lostPlayerId) => {
            addLog(`${PLAYERS[lostPlayerId].name} åŸºåœ°é™·è½ï¼`);
            const newPlayers = gameStateRef.current.players.map(p => p.id === lostPlayerId ? { ...p, isAlive: false } : p);
            const remainingUnits = gameStateRef.current.units.filter(u => u.owner !== lostPlayerId);
            let updates = { players: newPlayers, units: remainingUnits };
            const alivePlayers = newPlayers.filter(p => p.isAlive);
            if (alivePlayers.length === 1) { updates.gameOver = true; addLog(`ğŸ† ${alivePlayers[0].name} å‹åˆ©ï¼`, 'win'); if(audioEnabled) playSound('win'); }
            updateGameState(updates);
          };

          const startCardUse = (card, index) => {
              if(gameOver || isBotThinking) return;
              if(audioEnabled) playSound('card');
              const myUnits = units.filter(u => u.owner === turn);
              if (card.effect === 'BUFF_DMG') {
                  const newUnits = units.map(u => (u.owner === turn && (u.type === 'WARRIOR' || u.type === 'ASSASSIN')) ? { ...u, buffs: { ...u.buffs, doubleDamage: true } } : u);
                  updateGameState({ units: newUnits });
                  addLog('æˆ°å£«è£å¡«ç‹‚æš´å½ˆè—¥ï¼');
                  consumeCard(index);
                  return;
              }
              if (card.effect === 'BUFF_HP') {
                  setSelectedCard({ card, index });
                  setValidTargets(myUnits.filter(u => u.type === 'WARRIOR').map(u => ({ type: 'UNIT_BUFF_HP', id: u.id, x: u.x, y: u.y })));
                  resetSelection();
                  return;
              }
              if (card.effect === 'BUFF_STEALTH') {
                  setSelectedCard({ card, index });
                  setValidTargets(myUnits.filter(u => u.type === 'ASSASSIN').map(u => ({ type: 'UNIT_BUFF_STEALTH', id: u.id, x: u.x, y: u.y })));
                  resetSelection();
                  return;
              }
              setSelectedCard({ card, index });
              setValidMoves([]);
              resetSelection();
              if (card.effect === 'HEAL') {
                  setValidTargets(myUnits.map(u => ({ type: 'UNIT_HEAL', id: u.id, x: u.x, y: u.y })));
              } else if (card.effect === 'DMG') {
                  const visibleEnemies = units.filter(u => u.owner !== turn && !u.buffs?.stealth);
                  setValidTargets(visibleEnemies.map(u => ({ type: 'UNIT_DMG', id: u.id, x: u.x, y: u.y })));
              } else if (card.effect === 'BASE_HEAL') {
                  const myBase = bases.find(b => b.owner === turn);
                  // ä¿®æ”¹: æª¢æŸ¥æ˜¯å¦å°æ–¼æœ€å¤§ä¸Šé™ 15ï¼Œè€Œéåˆå§‹ 10
                  if (myBase.hp >= 15) { addLog('å¤§æœ¬ç‡Ÿè¡€é‡å·²é”ä¸Šé™ï¼Œä¸èƒ½ä½¿ç”¨'); if(audioEnabled) playSound('error'); setSelectedCard(null); return; }
                  updateGameState({ bases: bases.map(b => b.owner === turn ? {...b, hp: Math.min(b.hp + 5, 15)} : b) });
                  consumeCard(index);
                  setSelectedCard(null);
              }
          };

          const handleCardTargetClick = (target) => {
              if (!selectedCard) return;
              const currentUnits = gameStateRef.current.units;
              if (selectedCard.card.effect === 'BUFF_HP' && target.type === 'UNIT_BUFF_HP') {
                  updateGameState({ units: currentUnits.map(u => u.id === target.id ? {...u, hp: u.hp + 4} : u) });
                  consumeCard(selectedCard.index);
                  addLog('æˆ°å£«å¼·åŒ–è£ç”²éƒ¨ç½²å®Œç•¢ã€‚');
              }
              if (selectedCard.card.effect === 'BUFF_STEALTH' && target.type === 'UNIT_BUFF_STEALTH') {
                  updateGameState({ units: currentUnits.map(u => u.id === target.id ? {...u, buffs: {...u.buffs, stealth: true}} : u) });
                  consumeCard(selectedCard.index);
                  addLog('åˆºå®¢éå…¥é™°å½±ã€‚');
                  if(audioEnabled) playSound('stealth');
              }
              if (selectedCard.card.effect === 'HEAL' && target.type === 'UNIT_HEAL') {
                  updateGameState({ units: currentUnits.map(u => u.id === target.id ? {...u, hp: u.hp + 3} : u) });
                  consumeCard(selectedCard.index);
              } else if (selectedCard.card.effect === 'DMG' && target.type === 'UNIT_DMG') {
                  let targetUnit = units.find(u => u.id === target.id);
                  let newHp = targetUnit.hp - 2;
                  if (newHp <= 0) handleUnitDeath(target.id, targetUnit.type, targetUnit.owner);
                  else updateGameState({ units: currentUnits.map(u => u.id === target.id ? {...u, hp: newHp} : u) });
                  consumeCard(selectedCard.index);
              }
              if(audioEnabled && selectedCard.card.effect !== 'BUFF_STEALTH') playSound('card');
              setSelectedCard(null);
              setValidTargets([]);
          };

          const consumeCard = (index) => {
              const newPlayers = [...players];
              newPlayers[turn].cards.splice(index, 1);
              updateGameState({ players: newPlayers });
          };

          const nextTurn = () => {
            if (gameOver) return;
            resetSelection();
            setSelectedCard(null);
            setValidTargets([]);
            setAiAdvice(null);
            if(audioEnabled) playSound('turn_start');
            let nextPlayerId = (turn + 1) % 4;
            while (!players[nextPlayerId].isAlive) nextPlayerId = (nextPlayerId + 1) % 4;
            const newUnits = gameStateRef.current.units.map(u => {
                let newBuffs = { ...u.buffs };
                if (u.owner === nextPlayerId && u.buffs.stealth) delete newBuffs.stealth;
                return { ...u, hasActed: false, buffs: newBuffs };
            });
            updateGameState({ units: newUnits }); 
            setTurn(nextPlayerId);
            if (nextPlayerId === 0) { setRound(round + 1); spawnRandomItem(); }
            checkRespawns(nextPlayerId);
          };

          const spawnRandomItem = () => {
              if (Math.random() > 0.3) {
                let x, y, valid = false, attempts = 0;
                const currentBases = gameStateRef.current.bases;
                const size = gameStateRef.current.gridSize;
                do {
                    x = Math.floor(Math.random() * size);
                    y = Math.floor(Math.random() * size);
                    if (!currentBases.some(b => b.x === x && b.y === y)) valid = true;
                    attempts++;
                } while (!valid && attempts < 10);
                if (valid) {
                    updateGameState({ items: [...items, { x, y, type: 'CARD' }] });
                    addLog('âš¡ åµæ¸¬åˆ°æ–°å‹æ™¶ç‰‡è¨Šè™Ÿï¼');
                }
              }
          };

          const runBotTurn = async () => {
            setIsBotThinking(true);
            const botId = turn;
            await sleep(600);
            const myUnitIds = gameStateRef.current.units.filter(u => u.owner === botId).map(u => u.id);
            for (const unitId of myUnitIds) {
              const currentUnit = gameStateRef.current.units.find(u => u.id === unitId);
              if (!currentUnit) continue; 
              setSelectedUnitId(currentUnit.id);
              await sleep(300);
              const { units: currUnits, bases: currBases, items: currItems, gridSize: size } = gameStateRef.current;
              let actionTaken = false;
              if (currentUnit.type === 'WARRIOR' || currentUnit.type === 'ASSASSIN') {
                  const adjacents = [{x:currentUnit.x+1,y:currentUnit.y},{x:currentUnit.x-1,y:currentUnit.y},{x:currentUnit.x,y:currentUnit.y+1},{x:currentUnit.x,y:currentUnit.y-1}];
                  let attackTarget = null, targetType = null;
                  for (let pos of adjacents) {
                      const base = currBases.find(b => b.x === pos.x && b.y === pos.y && b.owner !== botId && b.hp > 0 && gameStateRef.current.players[b.owner].isAlive);
                      if (base) { attackTarget = base; targetType = 'BASE'; break; }
                      const enemy = currUnits.find(u => u.x === pos.x && u.y === pos.y && u.owner !== botId && !u.buffs?.stealth);
                      if (enemy) { attackTarget = enemy; targetType = 'UNIT'; break; }
                  }
                  if (attackTarget) { await performAttack(currentUnit.id, attackTarget.id, targetType); actionTaken = true; await sleep(300); }
              }
              if (!actionTaken) {
                  let target = null;
                  if (currentUnit.type === 'SCOUT' && currItems.length > 0) target = currItems.reduce((n, i) => (!n || getDistance(currentUnit, i) < getDistance(currentUnit, n)) ? i : n, null);
                  if (!target) {
                    const ens = [...currUnits.filter(u => u.owner !== botId && !u.buffs?.stealth), ...currBases.filter(b => b.owner !== botId && b.hp > 0)];
                    if(ens.length > 0) target = ens.reduce((n, e) => (!n || getDistance(currentUnit, e) < getDistance(currentUnit, n)) ? e : n, null);
                  }
                  if (target) {
                      const moves = [];
                      const range = UNIT_TYPES[currentUnit.type].moveRange;
                      for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            if (getDistance({x, y}, currentUnit) <= range && getDistance({x,y}, currentUnit) > 0) {
                                if (!currUnits.some(u => u.x === x && u.y === y) && !currBases.some(b => b.x === x && b.y === y)) moves.push({ x, y });
                            }
                        }
                      }
                      if (moves.length > 0) {
                          moves.sort((a, b) => getDistance(a, target) - getDistance(b, target));
                          await performMove(currentUnit.id, moves[0].x, moves[0].y);
                          await sleep(300);
                      }
                  }
              }
              setSelectedUnitId(null);
            }
            setIsBotThinking(false);
            nextTurn();
          };

          const handleSelectUnit = (unit) => {
            if (gameOver || isBotThinking || view !== 'GAME') return;
            if (unit.owner !== turn || unit.hasActed || selectedCard) return;
            if(audioEnabled) playSound('ui_click');
            setSelectedUnitId(unit.id);
            setIsAttacking(false);
            const moves = [];
            const range = UNIT_TYPES[unit.type].moveRange;
            const size = gameStateRef.current.gridSize;
            for (let x = 0; x < size; x++) {
              for (let y = 0; y < size; y++) {
                if (getDistance({x, y}, unit) <= range && getDistance({x,y}, unit) > 0) {
                  if (!units.some(u => u.x === x && u.y === y) && !bases.some(b => b.x === x && b.y === y)) moves.push({ x, y });
                }
              }
            }
            setValidMoves(moves);
            setValidTargets([]);
          };

          const prepareAttack = () => {
            const unit = units.find(u => u.id === selectedUnitId);
            if (!unit) return;
            if(audioEnabled) playSound('ui_click');
            setIsAttacking(true);
            setValidMoves([]);
            const targets = [];
            const adjs = [{x: unit.x+1, y: unit.y}, {x: unit.x-1, y: unit.y}, {x: unit.x, y: unit.y+1}, {x: unit.x, y: unit.y-1}];
            adjs.forEach(pos => {
              const eu = units.find(u => u.x === pos.x && u.y === pos.y && u.owner !== turn && !u.buffs?.stealth);
              if (eu) targets.push({ type: 'UNIT', id: eu.id, x: pos.x, y: pos.y });
              const eb = bases.find(b => b.x === pos.x && b.y === pos.y && b.owner !== turn);
              if (eb && players[eb.owner].isAlive) targets.push({ type: 'BASE', id: eb.id, x: pos.x, y: pos.y });
            });
            setValidTargets(targets);
            if (targets.length === 0) { addLog('ç›®æ¨™è„«é›¢ç¯„åœ'); if(audioEnabled) playSound('error'); setIsAttacking(false); }
          };

          const handleCellClick = (x, y) => {
            if (gameOver || isBotThinking || view !== 'GAME') return;
            if (selectedCard) {
                const t = validTargets.find(v => v.x === x && v.y === y);
                if (t) handleCardTargetClick(t); 
                else if (selectedCard.card.effect !== 'BUFF_HP' && selectedCard.card.effect !== 'BUFF_STEALTH') { setSelectedCard(null); setValidTargets([]); } 
                return;
            }
            if (isAttacking) {
              const t = validTargets.find(v => v.x === x && v.y === y);
              if (t) { performAttack(selectedUnitId, t.id, t.type); resetSelection(); } 
              else { setIsAttacking(false); setValidTargets([]); if(audioEnabled) playSound('ui_cancel'); }
              return;
            }
            const move = validMoves.find(m => m.x === x && m.y === y);
            if (move && !selectedCard) { performMove(selectedUnitId, x, y); resetSelection(); return; }
            const unit = units.find(u => u.x === x && u.y === y);
            if (unit) { handleSelectUnit(unit); return; }
            if (selectedUnitId) { resetSelection(); if(audioEnabled) playSound('ui_cancel'); }
          };

          const resetSelection = () => { setSelectedUnitId(null); setValidMoves([]); setIsAttacking(false); };

          const handleAskStrategy = async () => {
            if (isAiAdvising || gameOver) return;
            setIsAiAdvising(true);
            if(audioEnabled) playSound('ui_click');
            setAiAdvice("æƒææˆ°å ´æ•¸æ“š...");
            const advice = await callGemini(`æˆ°æ£‹è»å¸«ï¼Œæˆ‘æ–¹(ç´…)å‰© ${units.filter(u=>u.owner===0).length} å–®ä½ï¼Œçµ¦å€‹ç°¡çŸ­æˆ°è¡“å»ºè­°(20å­—å…§ç¹ä¸­)`);
            setAiAdvice(advice || "é€šè¨Šä¸­æ–·");
            setIsAiAdvising(false);
          };

          const renderCell = (x, y) => {
            const base = bases.find(b => b.x === x && b.y === y);
            const unit = units.find(u => u.x === x && u.y === y);
            const item = items.find(i => i.x === x && i.y === y);
            const isSelected = unit && unit.id === selectedUnitId;
            const isValidMove = validMoves.some(m => m.x === x && m.y === y);
            const isValidTarget = validTargets.some(t => t.x === x && t.y === y);
            const isHidden = unit && unit.owner !== 0 && unit.buffs?.stealth;
            const unitToRender = isHidden ? null : unit;

            let bgColor = 'bg-slate-900/80';
            if (base) bgColor = PLAYERS[base.owner].baseBg;
            if (isValidMove) bgColor = 'bg-cyan-500/20 shadow-[inset_0_0_10px_rgba(6,182,212,0.5)] cursor-pointer';
            if (isValidTarget) bgColor = 'bg-rose-500/30 shadow-[inset_0_0_15px_rgba(244,63,94,0.6)] cursor-pointer animate-pulse';

            // è¡€é‡æ¢è¨ˆç®—
            let hpBar = null;
            if (unitToRender) {
                const baseHp = UNIT_TYPES[unitToRender.type].hp;
                const hpPercent = Math.min(100, (unitToRender.hp / baseHp) * 100);
                const shieldPercent = unitToRender.hp > baseHp ? ((unitToRender.hp - baseHp) / baseHp) * 100 : 0;
                
                hpBar = (
                     <div className="w-9 h-1 bg-slate-800 mt-1 rounded-full border border-slate-600 overflow-hidden relative">
                        <div className={`h-full absolute top-0 left-0 transition-all ${unitToRender.hp <= 2 ? 'bg-red-500' : 'bg-green-400'}`} style={{ width: `${hpPercent}%` }}/>
                        {shieldPercent > 0 && <div className="h-full absolute top-0 left-0 bg-cyan-400/80 shadow-[0_0_5px_rgba(34,211,238,0.8)]" style={{ width: `${Math.min(100, shieldPercent)}%` }}/>}
                    </div>
                );
            }

            return (
              <div key={`${x}-${y}`} onClick={() => handleCellClick(x, y)} className={`w-full aspect-square border border-slate-700/50 relative flex items-center justify-center ${bgColor} transition-all duration-300 backdrop-blur-sm`}>
                <div className="absolute top-0 left-0 w-1 h-1 bg-slate-600/30"></div>
                <div className="absolute bottom-0 right-0 w-1 h-1 bg-slate-600/30"></div>
                {base && base.hp > 0 && (<div className="absolute inset-0 flex flex-col items-center justify-center opacity-40 pointer-events-none"><Castle className={PLAYERS[base.owner].text} size={28} /></div>)}
                {base && <div className="absolute top-0 right-0 text-[10px] font-bold text-slate-400 p-1 font-mono">{Math.max(0, base.hp)}</div>}
                {item && !unitToRender && (<div className="relative"><div className="absolute -inset-2 bg-yellow-400/30 blur-md rounded-full animate-pulse"></div><Zap className="text-yellow-400 relative z-10" size={20} /></div>)}
                {unitToRender && (
                  <div className={`relative z-10 flex flex-col items-center transition-all duration-300 ${isSelected ? 'scale-110 -translate-y-1' : ''} ${unitToRender.hasActed ? 'opacity-60 grayscale' : ''} ${unitToRender.buffs?.stealth ? 'opacity-40 animate-pulse' : ''}`}>
                    {unitToRender.buffs?.doubleDamage && <div className="absolute -top-4 text-orange-500 animate-bounce"><Flame size={14}/></div>}
                    {unitToRender.buffs?.stealth && <div className="absolute -top-4 left-4 text-cyan-400 animate-pulse"><Ghost size={12}/></div>}
                    <div className={`w-9 h-9 rounded-xl flex items-center justify-center shadow-lg border-2 ${PLAYERS[unitToRender.owner].color} ${PLAYERS[unitToRender.owner].border} text-white ${isSelected ? 'ring-2 ring-white shadow-cyan-500' : ''}`}>
                      {unitToRender.type === 'WARRIOR' && <Sword size={18} />}
                      {unitToRender.type === 'SCOUT' && <Eye size={18} />}
                      {unitToRender.type === 'ASSASSIN' && <Ghost size={18} />}
                    </div>
                    {hpBar}
                  </div>
                )}
                {isValidMove && !unitToRender && <div className="w-2 h-2 bg-cyan-400 rounded-full animate-ping"></div>}
              </div>
            );
          };

          if (view === 'MENU') {
              return (
                  <div className="min-h-screen bg-black text-slate-100 flex flex-col items-center justify-center p-4 relative overflow-hidden font-mono text-center">
                      <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 via-black to-black opacity-80"></div>
                      <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px)', backgroundSize: '40px 40px'}}></div>
                      <div className="z-10 space-y-10 animate-in fade-in zoom-in duration-700">
                          <div className="relative inline-block"><Castle size={80} className="text-cyan-400 relative z-10" /></div>
                          <div className="space-y-2"><h1 className="text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-500">å››åœ‹æˆ°æ£‹</h1><p className="text-cyan-200/60 text-lg tracking-[0.5em] uppercase font-bold">Cyber Tactics</p></div>
                          <div className="flex flex-col gap-4 w-full max-w-xs mx-auto">
                              <button onClick={() => initGame('STANDARD')} className="group px-8 py-4 bg-cyan-600/20 border border-cyan-500/50 hover:bg-cyan-500/40 transform skew-x-[-10deg] transition-all font-bold text-lg text-cyan-100 flex items-center justify-center gap-3"><Play className="transform skew-x-[10deg]"/> <span className="transform skew-x-[10deg]">æ¨™æº–æˆ°å½¹ (8x8)</span></button>
                              <button onClick={() => initGame('ASSASSIN')} className="group px-8 py-4 bg-purple-600/20 border border-purple-500/50 hover:bg-purple-500/40 transform skew-x-[-10deg] transition-all font-bold text-lg text-purple-100 flex items-center justify-center gap-3"><Ghost className="transform skew-x-[10deg]"/> <span className="transform skew-x-[10deg]">åˆºå®¢æ¨¡å¼ (10x10)</span></button>
                              <button onClick={() => setView('RULES')} className="px-8 py-3 bg-slate-800/50 border border-slate-700 transform skew-x-[-10deg] font-bold text-slate-300 hover:text-white transition-colors"><span className="transform skew-x-[10deg] block">è¦å‰‡ä»‹ç´¹</span></button>
                              <button onClick={() => setAudioEnabled(!audioEnabled)} className="text-slate-500 hover:text-cyan-400 flex items-center justify-center gap-2 text-sm">{audioEnabled ? <Volume2 size={16}/> : <VolumeX size={16}/>} éŸ³æ•ˆæ§åˆ¶</button>
                          </div>
                      </div>
                  </div>
              );
          }

          if (view === 'RULES') {
              return (
                  <div className="min-h-screen bg-slate-950 text-slate-100 flex flex-col p-4 md:p-8 font-sans overflow-y-auto scroll-smooth">
                      <div className="max-w-4xl mx-auto w-full space-y-6 animate-in slide-in-from-right duration-500">
                          <button onClick={() => { setView('MENU'); if(audioEnabled) playSound('ui_cancel'); }} className="flex items-center gap-2 text-cyan-400 hover:text-cyan-300 transition-colors font-bold tracking-wider sticky top-0 bg-slate-950/90 py-2 z-10 backdrop-blur"><ChevronLeft /> è¿”å›ä¸»é¸å–®</button>
                          <div className="glass-panel rounded-2xl p-6 md:p-10 shadow-2xl">
                              <h2 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-10 flex items-center gap-4 border-b border-slate-700 pb-6"><ScrollText className="text-cyan-500 w-10 h-10" /> æˆ°è¡“ä½œæˆ°æŒ‡å— (Tactical Guide)</h2>
                              <div className="space-y-12 text-slate-300">
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-4 flex items-center gap-3"><span className="p-2 bg-red-500/20 rounded-lg text-red-400"><User size={24}/></span> 1. ä½œæˆ°ç›®æ¨™ & å‹åˆ©æ¢ä»¶</h3>
                                      <div className="pl-4 border-l-2 border-slate-700 space-y-3">
                                          <p className="text-lg">ä½ æ˜¯æŒ‡æ® <span className="text-red-400 font-bold">ç´…éšŠ</span> çš„æŒ‡æ®å®˜ï¼Œå¿…é ˆåœ¨å››æ–¹æ··æˆ°ä¸­å­˜æ´»ã€‚</p>
                                          <div className="grid md:grid-cols-2 gap-4 mt-4">
                                              <div className="bg-slate-800/60 p-4 rounded-lg border border-slate-700"><div className="text-yellow-400 font-bold mb-1">ğŸ‘‘ å‹åˆ©æ¢ä»¶</div>æˆç‚ºæˆ°å ´ä¸Š <span className="text-white">å”¯ä¸€å­˜æ´»</span> çš„é™£ç‡Ÿã€‚</div>
                                              <div className="bg-slate-800/60 p-4 rounded-lg border border-slate-700"><div className="text-red-400 font-bold mb-1">ğŸ’€ å¤±æ•—æ¢ä»¶</div>æˆ‘æ–¹ <span className="text-white">å¤§æœ¬ç‡Ÿ HP æ­¸é›¶</span>ã€‚</div>
                                          </div>
                                      </div>
                                  </section>
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-6 flex items-center gap-3"><span className="p-2 bg-blue-500/20 rounded-lg text-blue-400"><Sword size={24}/></span> 2. æˆ°é¬¥å–®ä½æ•¸æ“šåº«</h3>
                                      <div className="grid lg:grid-cols-3 gap-6">
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-red-500/50 transition-colors">
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-red-900/50 rounded text-red-400"><Sword size={24}/></div><div><div className="font-black text-xl text-white">æˆ°å£« (Warrior)</div><div className="text-xs text-slate-500">ä¸»åŠ›è¼¸å‡º / å¦å…‹</div></div></div>
                                              <ul className="text-sm space-y-2"><li>â¤ï¸ ç”Ÿå‘½å€¼ï¼š<span className="text-green-400 font-mono text-lg">6</span></li><li>âš”ï¸ æ”»æ“ŠåŠ›ï¼š<span className="text-red-400 font-mono text-lg">3</span></li><li>ğŸ¦¶ ç§»å‹•åŠ›ï¼š<span className="text-blue-400 font-mono text-lg">2 æ ¼</span></li><li className="text-amber-400 mt-2 italic flex gap-2 items-start"><AlertTriangle size={14} className="shrink-0 mt-0.5"/> è¡Œå‹•é™åˆ¶ï¼šæ¯å›åˆèº«é«”åªèƒ½ã€Œç§»å‹•ã€æˆ–ã€Œæ”»æ“Šã€æ“‡ä¸€ã€‚</li></ul>
                                          </div>
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-blue-500/50 transition-colors">
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-blue-900/50 rounded text-blue-400"><Eye size={24}/></div><div><div className="font-black text-xl text-white">åµæŸ¥å…µ (Scout)</div><div className="text-xs text-slate-500">è³‡æºæ”¶é›† / å¿«é€Ÿ</div></div></div>
                                              <ul className="text-sm space-y-2"><li>â¤ï¸ ç”Ÿå‘½å€¼ï¼š<span className="text-green-400 font-mono text-lg">3</span></li><li>âš”ï¸ æ”»æ“ŠåŠ›ï¼š<span className="text-slate-500 font-mono">ç„¡æ³•æ”»æ“Š</span></li><li>ğŸ¦¶ ç§»å‹•åŠ›ï¼š<span className="text-blue-400 font-mono text-lg">2 æ ¼</span></li><li className="text-cyan-300 mt-2 flex gap-2 items-start"><Info size={14} className="shrink-0 mt-0.5"/> æˆ°ç•¥ç”¨é€”ï¼šä½”é ˜åœ°åœ–ä¸Šçš„æ©Ÿé‡å¡ <Zap size={10} className="inline"/>ã€‚</li></ul>
                                          </div>
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-purple-500/50 transition-colors relative overflow-hidden">
                                              <div className="absolute top-0 right-0 bg-purple-600 text-white text-[10px] px-2 py-1 rounded-bl font-bold">åˆºå®¢æ¨¡å¼é™å®š</div>
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-purple-900/50 rounded text-purple-400"><Ghost size={24}/></div><div><div className="font-black text-xl text-white">åˆºå®¢ (Assassin)</div><div className="text-xs text-slate-500">é«˜æ©Ÿå‹• / å¥‡è¥²</div></div></div>
                                              <ul className="text-sm space-y-2"><li>â¤ï¸ ç”Ÿå‘½å€¼ï¼š<span className="text-green-400 font-mono text-lg">4</span></li><li>âš”ï¸ æ”»æ“ŠåŠ›ï¼š<span className="text-red-400 font-mono text-lg">2</span></li><li>ğŸ¦¶ ç§»å‹•åŠ›ï¼š<span className="text-blue-400 font-mono text-lg">3 æ ¼</span></li><li className="text-purple-300 mt-2 flex gap-2 items-start"><Sparkles size={14} className="shrink-0 mt-0.5"/> ç‰¹æ®Šèƒ½åŠ›ï¼šå¯ä½¿ç”¨ã€Œéš±å½¢æŠ«é¢¨ã€é€²å…¥ç„¡æ³•è¢«é¸å–ç‹€æ…‹ã€‚</li></ul>
                                          </div>
                                      </div>
                                  </section>
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-6 flex items-center gap-3"><span className="p-2 bg-yellow-500/20 rounded-lg text-yellow-400"><Zap size={24}/></span> 3. æˆ°è¡“æ™¶ç‰‡ (æ©Ÿé‡å¡)</h3>
                                      <p className="mb-4 text-slate-400">ç•¶åµæŸ¥å…µç§»å‹•åˆ°é–ƒé›»æ¨™è¨˜æ ¼ <Zap size={14} className="inline text-yellow-400"/> æ™‚å¯ç²å¾—ï¼Œé–‹å±€æ¯äººéš¨æ©Ÿ 3 å¼µã€‚</p>
                                      <div className="grid md:grid-cols-2 gap-4">
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700 hover:bg-slate-800 transition-colors"><div className="p-2 bg-green-900/50 text-green-400 rounded shrink-0"><Heart size={20}/></div><div><div className="font-bold text-green-300 text-lg">æ€¥æ•‘åŒ…</div><div className="text-sm text-slate-400">æŒ‡å®šä»»ä¸€å–®ä½æ¢å¾© <span className="text-white font-bold">3 é»</span> HPã€‚</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700 hover:bg-slate-800 transition-colors"><div className="p-2 bg-red-900/50 text-red-400 rounded shrink-0"><Target size={20}/></div><div><div className="font-bold text-red-300 text-lg">ç‹™æ“Š</div><div className="text-sm text-slate-400">å°åœ°åœ–ä¸Šä»»æ„æ•µæ–¹å–®ä½é€ æˆ <span className="text-white font-bold">2 é»</span> å‚·å®³ (ç„¡è¦–è·é›¢)ã€‚</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700 hover:bg-slate-800 transition-colors"><div className="p-2 bg-blue-900/50 text-blue-400 rounded shrink-0"><Shield size={20}/></div><div><div className="font-bold text-blue-300 text-lg">åŸºåœ°è­·ç›¾</div><div className="text-sm text-slate-400">ä¿®å¾©å¤§æœ¬ç‡Ÿ <span className="text-white font-bold">5 é»</span> HP (ä¸Šé™15)ã€‚</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700 hover:bg-slate-800 transition-colors"><div className="p-2 bg-orange-900/50 text-orange-400 rounded shrink-0"><Flame size={20}/></div><div><div className="font-bold text-orange-300 text-lg">ç‹‚æš´é‡åŠ‘</div><div className="text-sm text-slate-400">æŒ‡å®šæˆ°å£«ä¸‹ä¸€æ¬¡æ”»æ“Šé€ æˆ <span className="text-white font-bold">é›™å€ (2x)</span> å‚·å®³ã€‚</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700 hover:bg-slate-800 transition-colors"><div className="p-2 bg-cyan-900/50 text-cyan-400 rounded shrink-0"><Plus size={20}/></div><div><div className="font-bold text-cyan-300 text-lg">å‹•åŠ›è£ç”²</div><div className="text-sm text-slate-400">æŒ‡å®šæˆ°å£«æ°¸ä¹…å¢åŠ  <span className="text-white font-bold">4 é»</span> HP (å¯çªç ´ä¸Šé™)ã€‚</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-purple-900/50 hover:bg-slate-800 transition-colors"><div className="p-2 bg-purple-900/50 text-purple-400 rounded shrink-0"><VenetianMask size={20}/></div><div><div className="font-bold text-purple-300 text-lg">éš±å½¢æŠ«é¢¨</div><div className="text-sm text-slate-400">åˆºå®¢å°ˆå±¬ï¼š<span className="text-white font-bold">éš±èº« 1 å›åˆ</span> (æ•µæ–¹ç„¡æ³•é¸ä¸­/æ”»æ“Š)ã€‚</div></div></div>
                                      </div>
                                  </section>
                              </div>
                          </div>
                      </div>
                  </div>
              );
          }

          return (
            <div className="min-h-screen bg-slate-950 text-slate-100 flex flex-col font-sans select-none scroll-smooth">
              <header className="px-4 py-3 bg-slate-900/80 backdrop-blur border-b border-slate-800 flex justify-between items-center sticky top-0 z-30">
                <div className="flex items-center gap-3">
                   <button onClick={quitGame} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white transition-colors"><ChevronLeft size={20}/></button>
                   <div><div className="text-[10px] text-slate-500 uppercase font-bold tracking-widest">Turn {round}</div><div className={`text-sm font-bold ${currentPlayer.text} flex items-center gap-2`}>{currentPlayer.name}</div></div>
                </div>
                <div className="flex gap-2">
                    <button onClick={nextTurn} disabled={isBotThinking || currentPlayer.isBot} className={`px-4 py-1.5 rounded text-sm font-bold flex items-center gap-2 transition-all ${isBotThinking || currentPlayer.isBot ? 'bg-slate-800 text-slate-600' : 'bg-cyan-600 hover:bg-cyan-500'}`}>çµæŸå›åˆ <Footprints size={14}/></button>
                </div>
              </header>

              <main className="flex-1 flex flex-col md:flex-row relative">
                <div className="flex-1 flex items-center justify-center p-4 bg-black">
                   <div className="relative">
                     <div className="grid gap-1 bg-slate-900/90 p-2 rounded-lg border border-slate-700 shadow-2xl relative z-10" style={{ gridTemplateColumns: `repeat(${gridSize}, minmax(30px, 1fr))`, width: 'min(90vw, 85vh)', maxWidth: '650px' }}>
                       {Array.from({ length: gridSize }).map((_, y) => Array.from({ length: gridSize }).map((_, x) => renderCell(x, y)))}
                     </div>
                     {gameOver && (<div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-50 backdrop-blur rounded-lg border border-yellow-500/30"><h1 className="text-5xl font-black text-yellow-400 mb-6">VICTORY</h1><button onClick={() => initGame(gameMode)} className="px-8 py-3 bg-white text-black font-bold flex items-center gap-2 rounded-lg">RESTART</button></div>)}
                   </div>
                </div>

                <div className="md:w-96 bg-slate-900 border-t md:border-t-0 md:border-l border-slate-800 flex flex-col shadow-2xl z-20">
                    <div className="p-3 bg-slate-900/50 border-b border-slate-800 grid grid-cols-2 gap-2 text-xs">
                        {players.map(p => {
                            // è¼”åŠ©å‡½å¼ï¼šå–å¾—å–®ä½ç‹€æ…‹ï¼ˆå­˜æ´»é¡¯ç¤ºHPï¼Œæ­»äº¡é¡¯ç¤ºå¾©æ´»å€’æ•¸ï¼‰
                            const getUnitStatus = (type) => {
                                const alive = units.find(u => u.owner === p.id && u.type === type);
                                if (alive) return `HP: ${alive.hp}`;
                                const dead = deadUnits.find(u => u.owner === p.id && u.type === type);
                                if (dead) return `å¾©æ´»: ${Math.max(1, dead.respawnRound - round)}T`;
                                return 'X';
                            };

                            return (
                                <div key={p.id} className={`p-2 rounded bg-slate-800/80 border ${p.isAlive ? 'border-slate-700 shadow-sm' : 'border-red-900/20 opacity-40'}`}>
                                    <div className={`font-bold ${p.text} mb-1`}>{p.name}</div>
                                    {p.isAlive ? (
                                        <div className="space-y-1">
                                            <div className="text-[10px] text-slate-400">æˆ°å£« {getUnitStatus('WARRIOR')}</div>
                                            <div className="text-[10px] text-slate-400">åµæŸ¥ {getUnitStatus('SCOUT')}</div>
                                            {gameMode === 'ASSASSIN' && <div className="text-[10px] text-slate-400">åˆºå®¢ {getUnitStatus('ASSASSIN')}</div>}
                                        </div>
                                    ) : <div className="text-slate-600 text-[10px] py-1">é™£ç‡Ÿé™·è½</div>}
                                </div>
                            );
                        })}
                    </div>

                    <div className="p-4 space-y-4">
                        {selectedUnit ? (
                            <div className="bg-slate-800/80 p-4 rounded-xl border border-slate-700 animate-in zoom-in-95">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-black text-white">{UNIT_TYPES[selectedUnit.type].name} (HP: {selectedUnit.hp})</span>
                                    {!isBotThinking && <button onClick={resetSelection} className="text-slate-500"><X size={16}/></button>}
                                </div>
                                {!isBotThinking && !selectedUnit.hasActed && currentPlayer.id === selectedUnit.owner && (
                                    <button onClick={prepareAttack} className="w-full py-2.5 bg-red-500/10 text-red-400 border border-red-500/40 rounded-lg font-bold">âš”ï¸ ç™¼èµ·æ”»æ“Š</button>
                                )}
                            </div>
                        ) : <div className="text-slate-700 text-center py-6 text-sm border-2 border-dashed border-slate-800 rounded-xl font-bold">é»æ“Šå–®ä½é€²è¡Œæ“ä½œ</div>}

                        {!isBotThinking && currentPlayer.id === 0 && (
                            <div className="mt-4">
                                <h3 className="text-[10px] font-black text-slate-500 uppercase tracking-widest mb-2">æˆ°è¡“æ™¶ç‰‡åˆ—è¡¨ ({currentPlayer.cards.length})</h3>
                                <div className="grid gap-2">
                                    {currentPlayer.cards.map((card, idx) => (
                                        <button key={idx} onClick={() => startCardUse(card, idx)} className="flex items-center gap-3 p-3 rounded-lg border border-slate-800 bg-slate-800/30 hover:border-cyan-500/50 text-left w-full">
                                            <div className="p-2 bg-slate-950 rounded text-cyan-400"><card.icon size={16}/></div>
                                            <div><div className="font-bold text-xs text-slate-200">{card.name}</div><div className="text-[9px] text-slate-500">{card.desc}</div></div>
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}
                        <div className="h-20"></div> {/* åº•éƒ¨ç·©è¡ç©ºé–“ */}
                    </div>
                </div>
              </main>
            </div>
          );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Tactics (Sync Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>

    <style>
        body { 
            background-color: #020617; 
            color: white; 
            overflow-y: auto; 
            touch-action: auto; 
            -webkit-overflow-scrolling: touch;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(51, 65, 85, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Sword, Eye, Castle, Zap, Heart, Shield, Footprints, X, Ghost, VenetianMask, Play, Wifi, Link, Copy, Volume2, VolumeX, ChevronLeft, ScrollText, User, Target, Flame, Plus, RotateCcw, RefreshCw } from 'lucide-react';

        const GEMINI_API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        // --- Èü≥ÊïàÁ≥ªÁµ± ---
        const audioCtx = typeof window !== 'undefined' ? new (window.AudioContext || window.webkitAudioContext)() : null;
        const playSound = (type) => {
          if (!audioCtx || audioCtx.state === 'suspended') audioCtx?.resume();
          if (!audioCtx) return;
          const osc = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          osc.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          const now = audioCtx.currentTime;

          const sounds = {
            move: () => { osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.15); gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15); osc.stop(now + 0.15); },
            attack: () => { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.2); gainNode.gain.setValueAtTime(0.2, now); osc.stop(now + 0.2); },
            stealth: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(400, now + 0.4); gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(0.1, now + 0.1); gainNode.gain.linearRampToValueAtTime(0, now + 0.4); osc.stop(now + 0.4); },
            respawn: () => { osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.5); gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.5); osc.stop(now + 0.5); },
            card: () => { osc.frequency.setValueAtTime(880, now); osc.frequency.exponentialRampToValueAtTime(1760, now + 0.3); gainNode.gain.setValueAtTime(0.1, now); osc.stop(now + 0.3); },
            damage: () => { osc.type = 'square'; osc.frequency.setValueAtTime(80, now); gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.2); osc.stop(now + 0.2); },
            ui_click: () => { osc.frequency.setValueAtTime(1000, now); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.05); osc.stop(now + 0.05); },
            turn_start: () => { osc.frequency.setValueAtTime(523, now); osc.frequency.setValueAtTime(659, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.3); osc.stop(now + 0.3); },
            connect: () => { osc.type = 'triangle'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.5); gainNode.gain.setValueAtTime(0.1, now); osc.stop(now + 0.5); },
          };
          
          if(sounds[type]) { osc.start(now); sounds[type](); }
        };

        const RESPAWN_TURNS = 3; 
        const BASE_HP = 10;
        const MAX_BASE_HP = 15;

        const PLAYERS = [
          { id: 0, name: 'Á¥ÖÈöä (HOST)', color: 'bg-red-600', text: 'text-red-500', border: 'border-red-500', baseBg: 'bg-red-900/30' },
          { id: 1, name: 'ËóçÈöä (CLIENT)', color: 'bg-blue-600', text: 'text-blue-500', border: 'border-blue-500', baseBg: 'bg-blue-900/30' },
          { id: 2, name: 'Á∂†Èöä (BOT)', color: 'bg-emerald-600', text: 'text-emerald-500', border: 'border-emerald-500', baseBg: 'bg-emerald-900/30' },
          { id: 3, name: 'ÈªÉÈöä (BOT)', color: 'bg-amber-500', text: 'text-amber-500', border: 'border-amber-500', baseBg: 'bg-amber-900/30' },
        ];

        const UNIT_TYPES = {
          WARRIOR: { name: 'Êà∞Â£´', hp: 6, atk: 3, icon: Sword, moveRange: 2 },
          SCOUT: { name: 'ÂÅµÊü•ÂÖµ', hp: 3, atk: 1, icon: Eye, moveRange: 2 },
          ASSASSIN: { name: 'Âà∫ÂÆ¢', hp: 4, atk: 2, icon: Ghost, moveRange: 3 },
        };

        const BASE_CARDS = [
          { id: 'heal', name: 'ÊÄ•ÊïëÂåÖ', desc: 'ÊÅ¢Âæ©ÂñÆ‰Ωç 3 HP', icon: Heart, effect: 'HEAL' },
          { id: 'snipe', name: 'ÁãôÊìä', desc: 'ÈÅ†Á®ã 2 ÂÇ∑ÂÆ≥', icon: Zap, effect: 'DMG' },
          { id: 'shield', name: 'Âü∫Âú∞Ë≠∑Áõæ', desc: 'Âü∫Âú∞ +5 HP', icon: Shield, effect: 'BASE_HEAL' },
          { id: 'berserk', name: 'ÁãÇÊö¥ÈáùÂäë', desc: '‰∏ã‰∏ÄÊ¨°ÊîªÊìäÈõôÂÄçÂÇ∑ÂÆ≥', icon: Flame, effect: 'BUFF_DMG' },
          { id: 'armor', name: 'ÂãïÂäõË£ùÁî≤', desc: 'ÊåáÂÆöÂñÆ‰Ωç +4 Max HP', icon: Plus, effect: 'BUFF_HP' },
        ];
        const ASSASSIN_CARDS = [...BASE_CARDS, { id: 'stealth', name: 'Èö±ÂΩ¢Êä´È¢®', desc: 'Èö±Ë∫´ 1 ÂõûÂêà', icon: VenetianMask, effect: 'BUFF_STEALTH' }];

        const getDistance = (p1, p2) => Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        async function callGemini(prompt) {
          try {
            const response = await fetch(GEMINI_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
            if (!response.ok) return null;
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
          } catch (error) { return null; }
        }

        function App() {
          const [view, setView] = useState('MENU');
          const [selectedMode, setSelectedMode] = useState('STANDARD'); 
          const [gameMode, setGameMode] = useState('STANDARD'); 
          const [gridSize, setGridSize] = useState(8);
          
          const [turn, setTurn] = useState(0);
          const [round, setRound] = useState(1);
          const [players, setPlayers] = useState([]);
          const [units, setUnits] = useState([]);
          const [deadUnits, setDeadUnits] = useState([]); 
          const [bases, setBases] = useState([]);
          const [items, setItems] = useState([]);
          const [logs, setLogs] = useState([]);
          const [gameOver, setGameOver] = useState(false);
          const [audioEnabled, setAudioEnabled] = useState(true);

          const [selectedUnitId, setSelectedUnitId] = useState(null);
          const [validMoves, setValidMoves] = useState([]);
          const [validTargets, setValidTargets] = useState([]);
          const [isAttacking, setIsAttacking] = useState(false);
          const [selectedCard, setSelectedCard] = useState(null);
          const [isBotThinking, setIsBotThinking] = useState(false);
          const [aiAdvice, setAiAdvice] = useState(null);
          const [isAiAdvising, setIsAiAdvising] = useState(false);

          const [isMultiplayer, setIsMultiplayer] = useState(false);
          const [isHost, setIsHost] = useState(false);
          const [myPeerId, setMyPeerId] = useState('');
          const [connectToId, setConnectToId] = useState('');
          const [myPlayerId, setMyPlayerId] = useState(0); 
          const [connectionStatus, setConnectionStatus] = useState('DISCONNECTED'); 

          // Ê†∏ÂøÉ‰øÆÂæ©Ôºö‰ΩøÁî® Ref ‰æÜËøΩËπ§ÊâÄÊúâÈÄ£Á∑öÁõ∏ÈóúÁãÄÊÖã
          // ÈÄôËÉΩËß£Ê±∫ PeerJS ‰∫ã‰ª∂Áõ£ËÅΩÂô®‰∏≠ÁöÑ„ÄåÈñâÂåÖÈô∑Èò± (Closure Trap)„ÄçÔºåÁ¢∫‰øùÂç≥‰ΩøÂú®ËàäÁöÑ‰∫ã‰ª∂ÂõûÂëº‰∏≠‰πüËÉΩËÆÄÂà∞ÊúÄÊñ∞ÁöÑÈÄ£Á∑öÁãÄÊÖã
          const connectionRef = useRef(null);
          const peerRef = useRef(null);
          const isHostRef = useRef(false);        // Êñ∞Â¢ûÔºöËøΩËπ§ÊòØÂê¶ÁÇ∫Êàø‰∏ª
          const isMultiplayerRef = useRef(false); // Êñ∞Â¢ûÔºöËøΩËπ§ÊòØÂê¶ÁÇ∫Â§ö‰∫∫Ê®°Âºè
          
          const currentPlayer = players[turn] || PLAYERS[0];
          const selectedUnit = units.find(u => u.id === selectedUnitId);
          const gameStateRef = useRef({ units, bases, items, players, gameOver, deadUnits, round, gridSize, turn, gameMode });

          useEffect(() => {
            gameStateRef.current = { units, bases, items, players, gameOver, deadUnits, round, gridSize, turn, gameMode };
          }, [units, bases, items, players, gameOver, deadUnits, round, gridSize, turn, gameMode]);

          useEffect(() => {
            return () => { 
                if(peerRef.current) peerRef.current.destroy(); 
            };
          }, []);

          const getDeck = (mode) => mode === 'ASSASSIN' ? ASSASSIN_CARDS : BASE_CARDS;

          const sanitizeStateForNetwork = (state) => {
              if (!state.players || state.players.length === 0) return state;
              const cleanPlayers = state.players.map(p => ({
                  ...p,
                  cards: p.cards.map(c => c.id) 
              }));
              return { 
                  ...state, 
                  players: cleanPlayers,
                  units: state.units,
                  bases: state.bases,
                  items: state.items,
                  deadUnits: state.deadUnits
              };
          };

          const rehydrateStateFromNetwork = (state) => {
              if (!state.players) return state;
              const deck = getDeck(state.gameMode || 'STANDARD');
              const hydratedPlayers = state.players.map(p => ({
                  ...p,
                  cards: p.cards.map(cardId => deck.find(c => c.id === cardId) || BASE_CARDS[0]) 
              }));
              return { ...state, players: hydratedPlayers };
          };

          const startMultiplayer = (role, modeToStart) => {
              if(audioEnabled) playSound('ui_click');
              
              if (peerRef.current) peerRef.current.destroy();
              
              const newPeer = new window.Peer();
              peerRef.current = newPeer;
              setConnectionStatus('CONNECTING');
              
              // ÂêåÊ≠•Êõ¥Êñ∞ Ref ÁãÄÊÖã
              const isHostRole = (role === 'HOST');
              setIsHost(isHostRole);
              isHostRef.current = isHostRole; 
              
              setIsMultiplayer(true);
              isMultiplayerRef.current = true;

              newPeer.on('open', (id) => {
                  setMyPeerId(id);
                  if (role === 'HOST') {
                      setMyPlayerId(0);
                      newPeer.on('connection', (c) => {
                          setupConnection(c, true, modeToStart);
                      });
                  } else {
                      setMyPlayerId(1);
                  }
              });

              newPeer.on('error', (err) => {
                  addLog('ÈÄ£Á∑öÈåØË™§: ' + err.type, 'error');
                  setConnectionStatus('ERROR');
              });
          };

          const joinGame = () => {
              if (!peerRef.current || !connectToId) return;
              if(audioEnabled) playSound('ui_click');
              
              // Âä†ÂÖ•ÊôÇ‰πüÁ¢∫Ë™çÊõ¥Êñ∞ÁãÄÊÖã
              setIsMultiplayer(true);
              isMultiplayerRef.current = true;
              setIsHost(false);
              isHostRef.current = false;

              const c = peerRef.current.connect(connectToId);
              setupConnection(c, false, null);
          };

          const setupConnection = (c, isHostSide, modeToStart) => {
              connectionRef.current = c;
              
              c.on('open', () => {
                  setConnectionStatus('CONNECTED');
                  if(audioEnabled) playSound('connect');
                  
                  if (isHostSide) {
                      initGame(modeToStart); 
                      setTimeout(() => broadcastState(), 100);
                  } else {
                      setView('GAME');
                      connectionRef.current.send({ type: 'REQ_FULL_SYNC' });
                      addLog('Â∑≤ÈÄ£Á∑öÔºåÊ≠£Âú®ÂêåÊ≠•...', 'system');
                  }
              });

              c.on('data', (data) => {
                  // ÈÄôË£°ÂÇ≥ÂÖ•ÁöÑ isHostSide ÊòØ setupConnection Âü∑Ë°åÊôÇÁöÑÈñâÂåÖËÆäÊï∏ÔºåÈÄôÊòØÂÆâÂÖ®ÁöÑ
                  handleNetworkData(data, isHostSide);
              });

              c.on('close', () => {
                  addLog('Â∞çÊâãÂ∑≤Êñ∑Á∑ö', 'error');
                  setConnectionStatus('DISCONNECTED');
                  setGameOver(true);
              });
          };

          const handleNetworkData = (data, amIHost) => {
              if (data.type === 'SYNC') {
                  if (!amIHost) {
                      const s = rehydrateStateFromNetwork(data.state);
                      
                      setUnits(s.units || []);
                      setPlayers(s.players || []);
                      setBases(s.bases || []);
                      setItems(s.items || []);
                      setDeadUnits(s.deadUnits || []);
                      setTurn(s.turn);
                      setRound(s.round);
                      setGameOver(s.gameOver);
                      setLogs(prev => s.lastLog ? [{text: s.lastLog.text, type: s.lastLog.type}, ...prev].slice(0,8) : prev);
                      setGridSize(s.gridSize);
                      setGameMode(s.gameMode);
                      
                      gameStateRef.current = { ...gameStateRef.current, ...s };
                      
                      if(data.sound && audioEnabled) playSound(data.sound);
                  }
              } 
              else if (data.type === 'REQ_FULL_SYNC') {
                  if (amIHost) {
                      addLog('ÂÆ¢Á´ØÂ∑≤Âä†ÂÖ•ÔºåÁôºÈÄÅÂêåÊ≠•Êï∏Êìö', 'system');
                      broadcastState();
                  }
              }
              else if (amIHost) {
                  handleClientRequest(data);
              }
          };

          const handleClientRequest = async (req) => {
              if (gameStateRef.current.turn !== 1) {
                  return;
              }
              
              // ÈÄô‰∫õÂáΩÂºèÊúÉÂëºÂè´ updateGameState -> broadcastState
              // Áî±Êñº‰ΩøÁî®‰∫Ü isHostRefÔºåÂç≥‰ΩøÂú®ÈÄôË£°Ë™øÁî®Ôºå‰πüËÉΩÊ≠£Á¢∫Âª£Êí≠
              if (req.type === 'REQ_MOVE') {
                  await performMove(req.unitId, req.x, req.y);
              } else if (req.type === 'REQ_ATTACK') {
                  await performAttack(req.attackerId, req.targetId, req.targetType);
              } else if (req.type === 'REQ_END_TURN') {
                  nextTurn();
              } else if (req.type === 'REQ_CARD') {
                  applyCardEffect(req.cardIndex, req.target, 1);
              }
          };

          const broadcastState = (soundEffect = null, logMsg = null) => {
              // ÈóúÈçµ‰øÆÂæ©Ôºö‰ΩøÁî® Ref Ê™¢Êü•ÔºåËÄå‰∏çÊòØ state
              if (!connectionRef.current || !isHostRef.current) return;
              
              const state = gameStateRef.current;
              
              const cleanState = sanitizeStateForNetwork({
                  units: state.units,
                  players: state.players,
                  bases: state.bases,
                  items: state.items,
                  deadUnits: state.deadUnits,
                  turn: state.turn,
                  round: state.round,
                  gameOver: state.gameOver,
                  gridSize: state.gridSize,
                  gameMode: state.gameMode,
                  lastLog: logMsg ? {text: logMsg, type: 'system'} : null
              });

              try {
                connectionRef.current.send({
                    type: 'SYNC',
                    state: cleanState,
                    sound: soundEffect
                });
              } catch (e) {
                  console.error("Broadcast failed:", e);
              }
          };

          const canControl = () => {
              if (gameOver || isBotThinking) return false;
              if (isMultiplayer) {
                  return turn === myPlayerId; 
              }
              return !players[turn].isBot; 
          };

          useEffect(() => {
            if (view === 'GAME' && !gameOver) {
                const currentP = players[turn];
                if (!currentP) return;
                if (isMultiplayer) {
                    if (isHost && (currentP.id === 2 || currentP.id === 3)) {
                        runBotTurn();
                    }
                } else {
                    if (currentP.isBot) runBotTurn();
                }
            }
          }, [turn, gameOver, view]);

          const initGame = (mode) => {
            setGameMode(mode);
            const size = mode === 'ASSASSIN' ? 10 : 8;
            setGridSize(size);

            const newBases = [
              { id: 0, owner: 0, x: 0, y: 0, hp: BASE_HP },
              { id: 1, owner: 1, x: size - 1, y: 0, hp: BASE_HP },
              { id: 2, owner: 2, x: 0, y: size - 1, hp: BASE_HP },
              { id: 3, owner: 3, x: size - 1, y: size - 1, hp: BASE_HP },
            ];

            let newUnits = [
              { id: 'r_w', owner: 0, type: 'WARRIOR', x: 1, y: 0, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'r_s', owner: 0, type: 'SCOUT', x: 0, y: 1, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'b_w', owner: 1, type: 'WARRIOR', x: size - 2, y: 0, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'b_s', owner: 1, type: 'SCOUT', x: size - 1, y: 1, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'g_w', owner: 2, type: 'WARRIOR', x: 1, y: size - 1, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'g_s', owner: 2, type: 'SCOUT', x: 0, y: size - 2, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
              { id: 'y_w', owner: 3, type: 'WARRIOR', x: size - 2, y: size - 1, hp: UNIT_TYPES.WARRIOR.hp, hasActed: false, buffs: {} },
              { id: 'y_s', owner: 3, type: 'SCOUT', x: size - 1, y: size - 2, hp: UNIT_TYPES.SCOUT.hp, hasActed: false, buffs: {} },
            ];

            if (mode === 'ASSASSIN') {
                newUnits.push(
                    { id: 'r_a', owner: 0, type: 'ASSASSIN', x: 1, y: 1, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'b_a', owner: 1, type: 'ASSASSIN', x: size - 2, y: 1, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'g_a', owner: 2, type: 'ASSASSIN', x: 1, y: size - 2, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} },
                    { id: 'y_a', owner: 3, type: 'ASSASSIN', x: size - 2, y: size - 2, hp: UNIT_TYPES.ASSASSIN.hp, hasActed: false, buffs: {} }
                );
            }

            const deck = mode === 'ASSASSIN' ? ASSASSIN_CARDS : BASE_CARDS;
            const initialPlayers = PLAYERS.map(p => {
                const hand = [];
                for(let i=0; i<3; i++) hand.push(deck[Math.floor(Math.random() * deck.length)]);
                let isBot = p.id > 1; 
                if (!isMultiplayer && p.id === 1) isBot = true; 
                return { ...p, isAlive: true, cards: hand, isBot: isBot };
            });

            const initialItems = [{ x: Math.floor(size/2), y: Math.floor(size/2), type: 'CARD' }, { x: Math.floor(size/2)-1, y: Math.floor(size/2)-1, type: 'CARD' }];

            setBases(newBases);
            setUnits(newUnits);
            setItems(initialItems);
            setLogs([{ text: mode === 'ASSASSIN' ? 'Âà∫ÂÆ¢Ê®°ÂºèÂïüÂãïÔºÅ' : 'Ê®ôÊ∫ñÊà∞ÂΩπÈñãÂßãÔºÅ', type: 'system' }]);
            setPlayers(initialPlayers);
            setDeadUnits([]);
            setTurn(0);
            setRound(1);
            setGameOver(false);
            setAiAdvice(null);
            setValidMoves([]);
            setSelectedUnitId(null);
            setView('GAME');
            if(audioEnabled) playSound('turn_start');

            gameStateRef.current = {
                units: newUnits,
                bases: newBases,
                items: initialItems,
                players: initialPlayers,
                gameOver: false,
                deadUnits: [],
                round: 1,
                gridSize: size,
                turn: 0,
                gameMode: mode
            };
          };

          const addLog = (msg, type = 'system') => { 
              setLogs(prev => [{ text: msg, type }, ...prev].slice(0, 8)); 
          };

          const updateGameState = (updates, sound = null, logMsg = null) => {
              if (updates.units) setUnits(updates.units);
              if (updates.players) setPlayers(updates.players);
              if (updates.bases) setBases(updates.bases);
              if (updates.items) setItems(updates.items);
              if (updates.deadUnits) setDeadUnits(updates.deadUnits);
              if (updates.gameOver !== undefined) setGameOver(updates.gameOver);
              
              gameStateRef.current = { ...gameStateRef.current, ...updates };

              // ÈóúÈçµ‰øÆÂæ©Ôºö‰ΩøÁî® Ref Âà§Êñ∑ÊòØÂê¶ÈúÄË¶ÅÂª£Êí≠
              // Ëàä‰ª£Á¢ºÊ™¢Êü• isMultiplayer (state)ÔºåÂú® Peer ‰∫ã‰ª∂ÁöÑÂõûË™ø‰∏≠ÊúÉÊòØ false (ÈñâÂåÖËÆäÊï∏ÈÅéÊúü)
              // ‰ΩøÁî® Ref ÂèØ‰ª•Á¢∫‰øùÂç≥‰ΩøÂú®ÈÅéÊúüÁöÑÈñâÂåÖ‰∏≠Ôºå‰πüËÉΩÊ≠£Á¢∫Ëß∏ÁôºÂª£Êí≠
              if (isMultiplayerRef.current && isHostRef.current) {
                  broadcastState(sound, logMsg);
              }
          };

          const checkRespawns = (currentPlayerId) => {
              const { deadUnits: currentDead, round: currentRound, gridSize: size } = gameStateRef.current;
              const toRespawn = currentDead.filter(d => d.owner === currentPlayerId && d.respawnRound <= currentRound);
              const stillDead = currentDead.filter(d => !(d.owner === currentPlayerId && d.respawnRound <= currentRound));
              if (toRespawn.length === 0) return;

              let currentUnits = [...gameStateRef.current.units];
              const base = gameStateRef.current.bases.find(b => b.owner === currentPlayerId);

              toRespawn.forEach(d => {
                  let spawnPos = { x: base.x, y: base.y };
                  const isOccupied = (tx, ty) => currentUnits.some(u => u.x === tx && u.y === ty);
                  if (isOccupied(base.x, base.y)) {
                      const adjacents = [{x:base.x+1,y:base.y},{x:base.x-1,y:base.y},{x:base.x,y:base.y+1},{x:base.x,y:base.y-1}]
                                        .filter(p => p.x >=0 && p.x < size && p.y >=0 && p.y < size);
                      const freeSpot = adjacents.find(p => !isOccupied(p.x, p.y));
                      if (freeSpot) spawnPos = freeSpot;
                      else return; 
                  }
                  const newUnit = { id: `${currentPlayerId}_${d.type}_${Date.now()}_${Math.random()}`, owner: currentPlayerId, type: d.type, x: spawnPos.x, y: spawnPos.y, hp: UNIT_TYPES[d.type].hp, hasActed: false, buffs: {} };
                  currentUnits.push(newUnit);
                  addLog(`${PLAYERS[currentPlayerId].name} ÁöÑ ${UNIT_TYPES[d.type].name} Âæ©Ê¥ª„ÄÇ`, 'system');
                  if(audioEnabled) playSound('respawn');
              });
              updateGameState({ units: currentUnits, deadUnits: stillDead });
          };

          const handleUnitDeath = (unitId, unitType, ownerId) => {
             const respawnRound = gameStateRef.current.round + RESPAWN_TURNS;
             const newDead = [...gameStateRef.current.deadUnits, { type: unitType, owner: ownerId, respawnRound }];
             const newUnits = gameStateRef.current.units.filter(u => u.id !== unitId);
             updateGameState({ units: newUnits, deadUnits: newDead });
          };

          const performMove = async (unitId, x, y) => {
             // ÂÆ¢Á´ØÁôºÈÄÅË´ãÊ±ÇÈÇèËºØ
             if (isMultiplayerRef.current && !isHostRef.current) {
                 if (connectionRef.current) {
                    connectionRef.current.send({ type: 'REQ_MOVE', unitId, x, y });
                 }
                 return;
             }

             const unit = gameStateRef.current.units.find(u => u.id === unitId);
             if (!unit) return;
             if(audioEnabled) playSound('move');
             let newUnits = gameStateRef.current.units.map(u => u.id === unitId ? { ...u, x, y, hasActed: true } : u);
             let stateUpdates = { units: newUnits };
             const itemIndex = gameStateRef.current.items.findIndex(i => i.x === x && i.y === y);
             
             if (itemIndex !== -1 && unit.type === 'SCOUT') {
                 const deck = gameMode === 'ASSASSIN' ? ASSASSIN_CARDS : BASE_CARDS;
                 const randomCard = deck[Math.floor(Math.random() * deck.length)];
                 const newPlayers = gameStateRef.current.players.map(p => 
                     p.id === unit.owner ? { ...p, cards: [...p.cards, randomCard] } : p
                 );
                 const newItems = [...gameStateRef.current.items];
                 newItems.splice(itemIndex, 1);
                 addLog(`${PLAYERS[unit.owner].name} Áç≤Âèñ‰∫Ü ${randomCard.name}`);
                 if(audioEnabled) playSound('card');
                 stateUpdates.players = newPlayers;
                 stateUpdates.items = newItems;
             }
             updateGameState(stateUpdates, 'move'); 
          };

          const performAttack = async (attackerId, targetId, targetType) => {
              if (isMultiplayerRef.current && !isHostRef.current) {
                 if (connectionRef.current) {
                    connectionRef.current.send({ type: 'REQ_ATTACK', attackerId, targetId, targetType });
                 }
                 return;
              }

              const attackerUnit = gameStateRef.current.units.find(u => u.id === attackerId);
              if (!attackerUnit || attackerUnit.hasActed) return;
              let dmg = UNIT_TYPES[attackerUnit.type].atk;
              if (attackerUnit.buffs?.doubleDamage) dmg *= 2;
              
              if(audioEnabled) playSound('attack');
              let stateUpdates = {};
              
              if (targetType === 'UNIT') {
                  const targetUnit = gameStateRef.current.units.find(u => u.id === targetId);
                  if(!targetUnit) return;
                  const newHp = targetUnit.hp - dmg;
                  if(audioEnabled) playSound('damage');
                  let newUnits = gameStateRef.current.units.map(u => u.id === targetId ? { ...u, hp: newHp } : u);
                  addLog(`${PLAYERS[attackerUnit.owner].name} ÊîªÊìä ${PLAYERS[targetUnit.owner].name} ÈÄ†Êàê ${dmg} ÂÇ∑ÂÆ≥`);
                  if (newHp <= 0) {
                      addLog('ÊìäÁ†¥ÁõÆÊ®ôÂñÆ‰ΩçÔºÅ');
                      handleUnitDeath(targetId, targetUnit.type, targetUnit.owner);
                      newUnits = gameStateRef.current.units; 
                  }
                  newUnits = newUnits.map(u => u.id === attackerId ? { ...u, hasActed: true, buffs: { ...u.buffs, doubleDamage: false, stealth: false } } : u);
                  stateUpdates.units = newUnits;
              } else if (targetType === 'BASE') {
                  const targetBase = gameStateRef.current.bases.find(b => b.id === targetId);
                  const newHp = targetBase.hp - dmg;
                  const newBases = gameStateRef.current.bases.map(b => b.id === targetId ? { ...b, hp: newHp } : b);
                  let newUnits = gameStateRef.current.units.map(u => u.id === attackerId ? { ...u, hasActed: true, buffs: { ...u.buffs, doubleDamage: false, stealth: false } } : u);
                  stateUpdates.units = newUnits;
                  stateUpdates.bases = newBases;
                  addLog(`ÊîªÊìäÂ§ßÊú¨ÁáüÔºÅÂâ©È§ò HP ${Math.max(0, newHp)}`);
                  if(audioEnabled) playSound('damage');
                  if (newHp <= 0) { updateGameState(stateUpdates, 'damage'); handlePlayerDefeat(targetBase.owner); return; }
              }
              updateGameState(stateUpdates, 'damage');
          };

          const handlePlayerDefeat = (lostPlayerId) => {
            addLog(`${PLAYERS[lostPlayerId].name} Âü∫Âú∞Èô∑ËêΩÔºÅ`);
            const newPlayers = gameStateRef.current.players.map(p => p.id === lostPlayerId ? { ...p, isAlive: false } : p);
            const remainingUnits = gameStateRef.current.units.filter(u => u.owner !== lostPlayerId);
            let updates = { players: newPlayers, units: remainingUnits };
            const alivePlayers = newPlayers.filter(p => p.isAlive);
            if (alivePlayers.length === 1) { updates.gameOver = true; addLog(`üèÜ ${alivePlayers[0].name} ÂãùÂà©ÔºÅ`, 'win'); if(audioEnabled) playSound('win'); }
            updateGameState(updates, 'win');
          };

          const applyCardEffect = (cardIndex, target, playerId) => {
              const p = gameStateRef.current.players[playerId];
              if (!p || !p.cards[cardIndex]) return;
              const card = p.cards[cardIndex];
              const currentUnits = gameStateRef.current.units;

              let updates = {};
              let sound = 'card';
              let log = '';

              if (card.effect === 'BUFF_HP' && target.type === 'UNIT_BUFF_HP') {
                  updates.units = currentUnits.map(u => u.id === target.id ? {...u, hp: u.hp + 4} : u);
                  log = 'Êà∞Â£´Âº∑ÂåñË£ùÁî≤ÈÉ®ÁΩ≤ÂÆåÁï¢„ÄÇ';
              }
              if (card.effect === 'BUFF_STEALTH' && target.type === 'UNIT_BUFF_STEALTH') {
                  updates.units = currentUnits.map(u => u.id === target.id ? {...u, buffs: {...u.buffs, stealth: true}} : u);
                  log = 'Âà∫ÂÆ¢ÈÅÅÂÖ•Èô∞ÂΩ±„ÄÇ';
                  sound = 'stealth';
              }
              if (card.effect === 'HEAL' && target.type === 'UNIT_HEAL') {
                  updates.units = currentUnits.map(u => u.id === target.id ? {...u, hp: u.hp + 3} : u);
                  log = 'ÂñÆ‰Ωç‰øÆÂæ©ÂÆåÊàê„ÄÇ';
              } 
              else if (card.effect === 'DMG' && target.type === 'UNIT_DMG') {
                  let targetUnit = currentUnits.find(u => u.id === target.id);
                  let newHp = targetUnit.hp - 2;
                  if (newHp <= 0) handleUnitDeath(target.id, targetUnit.type, targetUnit.owner);
                  else updates.units = currentUnits.map(u => u.id === target.id ? {...u, hp: newHp} : u);
                  log = 'ÁãôÊìäÂëΩ‰∏≠ÔºÅ';
                  sound = 'attack';
              }

              const newPlayers = gameStateRef.current.players.map((pl, idx) => 
                  idx === playerId ? { ...pl, cards: pl.cards.filter((_, i) => i !== cardIndex) } : pl
              );
              updates.players = newPlayers;

              if (log) addLog(log);
              if (audioEnabled) playSound(sound);
              updateGameState(updates, sound);
          };

          const startCardUse = (card, index) => {
              if (gameOver || isBotThinking || !canControl()) return;
              if (audioEnabled) playSound('card');
              
              const myUnits = units.filter(u => u.owner === turn);
              
              if (card.effect === 'BUFF_DMG') {
                  if (isMultiplayerRef.current && !isHostRef.current) {
                       connectionRef.current?.send({ type: 'REQ_CARD', cardIndex: index, target: { type: 'SELF' } });
                       return;
                  }
                  const newUnits = units.map(u => (u.owner === turn && (u.type === 'WARRIOR' || u.type === 'ASSASSIN')) ? { ...u, buffs: { ...u.buffs, doubleDamage: true } } : u);
                  addLog('Êà∞Â£´Ë£ùÂ°´ÁãÇÊö¥ÂΩàËó•ÔºÅ');
                  const newPlayers = players.map((p, i) => i === turn ? { ...p, cards: p.cards.filter((_, i) => i !== index) } : p);
                  updateGameState({ units: newUnits, players: newPlayers }, 'card');
                  return;
              }
              if (card.effect === 'BASE_HEAL') {
                  const myBase = bases.find(b => b.owner === turn);
                  if (myBase.hp >= MAX_BASE_HP) { 
                      addLog('Â§ßÊú¨ÁáüË°ÄÈáèÂ∑≤ÈÅî‰∏äÈôêÔºå‰∏çËÉΩ‰ΩøÁî®'); 
                      if(audioEnabled) playSound('error'); 
                      return; 
                  }
                  if (isMultiplayerRef.current && !isHostRef.current) {
                       connectionRef.current?.send({ type: 'REQ_CARD', cardIndex: index, target: { type: 'BASE' } });
                       return;
                  }
                  updateGameState({ bases: bases.map(b => b.owner === turn ? {...b, hp: Math.min(b.hp + 5, MAX_BASE_HP)} : b) });
                  const newPlayers = players.map((p, i) => i === turn ? { ...p, cards: p.cards.filter((_, i) => i !== index) } : p);
                  updateGameState({ players: newPlayers }, 'card');
                  return;
              }

              setSelectedCard({ card, index });
              setValidMoves([]);
              resetSelection();

              if (card.effect === 'BUFF_HP') {
                  setValidTargets(myUnits.filter(u => u.type === 'WARRIOR').map(u => ({ type: 'UNIT_BUFF_HP', id: u.id, x: u.x, y: u.y })));
              } else if (card.effect === 'BUFF_STEALTH') {
                  setValidTargets(myUnits.filter(u => u.type === 'ASSASSIN').map(u => ({ type: 'UNIT_BUFF_STEALTH', id: u.id, x: u.x, y: u.y })));
              } else if (card.effect === 'HEAL') {
                  setValidTargets(myUnits.map(u => ({ type: 'UNIT_HEAL', id: u.id, x: u.x, y: u.y })));
              } else if (card.effect === 'DMG') {
                  const visibleEnemies = units.filter(u => u.owner !== turn && !u.buffs?.stealth);
                  setValidTargets(visibleEnemies.map(u => ({ type: 'UNIT_DMG', id: u.id, x: u.x, y: u.y })));
              }
          };

          const handleCardTargetClick = (target) => {
              if (!selectedCard) return;
              if (isMultiplayerRef.current && !isHostRef.current) {
                  connectionRef.current?.send({ type: 'REQ_CARD', cardIndex: selectedCard.index, target });
                  setSelectedCard(null);
                  setValidTargets([]);
                  return;
              }
              applyCardEffect(selectedCard.index, target, turn);
              setSelectedCard(null);
              setValidTargets([]);
          };

          const nextTurn = () => {
            if (isMultiplayerRef.current && !isHostRef.current) {
                connectionRef.current?.send({ type: 'REQ_END_TURN' });
                return;
            }

            if (gameOver) return;
            resetSelection();
            setSelectedCard(null);
            setValidTargets([]);
            setAiAdvice(null);
            if(audioEnabled) playSound('turn_start');
            
            let nextPlayerId = (turn + 1) % 4;
            while (!gameStateRef.current.players[nextPlayerId].isAlive) nextPlayerId = (nextPlayerId + 1) % 4;
            
            const newUnits = gameStateRef.current.units.map(u => {
                let newBuffs = { ...u.buffs };
                if (u.owner === nextPlayerId && u.buffs.stealth) delete newBuffs.stealth;
                return { ...u, hasActed: false, buffs: newBuffs };
            });
            
            updateGameState({ units: newUnits }); 
            setTurn(nextPlayerId);
            
            if (nextPlayerId === 0) { 
                setRound(round + 1); 
                spawnRandomItem(); 
            }
            checkRespawns(nextPlayerId);
            updateGameState({ turn: nextPlayerId }, 'turn_start');
          };

          const spawnRandomItem = () => {
              if (Math.random() > 0.3) {
                let x, y, valid = false, attempts = 0;
                const currentBases = gameStateRef.current.bases;
                const size = gameStateRef.current.gridSize;
                do {
                    x = Math.floor(Math.random() * size);
                    y = Math.floor(Math.random() * size);
                    if (!currentBases.some(b => b.x === x && b.y === y)) valid = true;
                    attempts++;
                } while (!valid && attempts < 10);
                if (valid) {
                    updateGameState({ items: [...items, { x, y, type: 'CARD' }] });
                    addLog('‚ö° ÂÅµÊ∏¨Âà∞Êñ∞ÂûãÊô∂ÁâáË®äËôüÔºÅ');
                }
              }
          };

          const runBotTurn = async () => {
            setIsBotThinking(true);
            const botId = turn; 
            await sleep(600);
            const myUnitIds = gameStateRef.current.units.filter(u => u.owner === botId).map(u => u.id);
            for (const unitId of myUnitIds) {
              const currentUnit = gameStateRef.current.units.find(u => u.id === unitId);
              if (!currentUnit) continue; 
              setSelectedUnitId(currentUnit.id); 
              await sleep(300);
              const { units: currUnits, bases: currBases, items: currItems, gridSize: size } = gameStateRef.current;
              let actionTaken = false;
              
              if (currentUnit.type === 'WARRIOR' || currentUnit.type === 'ASSASSIN') {
                  const adjacents = [{x:currentUnit.x+1,y:currentUnit.y},{x:currentUnit.x-1,y:currentUnit.y},{x:currentUnit.x,y:currentUnit.y+1},{x:currentUnit.x,y:currentUnit.y-1}];
                  let attackTarget = null, targetType = null;
                  for (let pos of adjacents) {
                      const base = currBases.find(b => b.x === pos.x && b.y === pos.y && b.owner !== botId && b.hp > 0 && gameStateRef.current.players[b.owner].isAlive);
                      if (base) { attackTarget = base; targetType = 'BASE'; break; }
                      const enemy = currUnits.find(u => u.x === pos.x && u.y === pos.y && u.owner !== botId && !u.buffs?.stealth);
                      if (enemy) { attackTarget = enemy; targetType = 'UNIT'; break; }
                  }
                  if (attackTarget) { await performAttack(currentUnit.id, attackTarget.id, targetType); actionTaken = true; await sleep(300); }
              }
              if (!actionTaken) {
                  let target = null;
                  if (currentUnit.type === 'SCOUT' && currItems.length > 0) target = currItems.reduce((n, i) => (!n || getDistance(currentUnit, i) < getDistance(currentUnit, n)) ? i : n, null);
                  if (!target) {
                    const ens = [...currUnits.filter(u => u.owner !== botId && !u.buffs?.stealth), ...currBases.filter(b => b.owner !== botId && b.hp > 0)];
                    if(ens.length > 0) target = ens.reduce((n, e) => (!n || getDistance(currentUnit, e) < getDistance(currentUnit, n)) ? e : n, null);
                  }
                  if (target) {
                      const moves = [];
                      const range = UNIT_TYPES[currentUnit.type].moveRange;
                      for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            if (getDistance({x, y}, currentUnit) <= range && getDistance({x,y}, currentUnit) > 0) {
                                if (!currUnits.some(u => u.x === x && u.y === y) && !currBases.some(b => b.x === x && b.y === y)) moves.push({ x, y });
                            }
                        }
                      }
                      if (moves.length > 0) {
                          moves.sort((a, b) => getDistance(a, target) - getDistance(b, target));
                          await performMove(currentUnit.id, moves[0].x, moves[0].y);
                          await sleep(300);
                      }
                  }
              }
              setSelectedUnitId(null);
            }
            setIsBotThinking(false);
            nextTurn();
          };

          const handleSelectUnit = (unit) => {
            if (gameOver || isBotThinking || view !== 'GAME') return;
            if (!canControl()) return; 
            if (unit.owner !== turn || unit.hasActed || selectedCard) return;
            
            if(audioEnabled) playSound('ui_click');
            setSelectedUnitId(unit.id);
            setIsAttacking(false);
            
            const moves = [];
            const range = UNIT_TYPES[unit.type].moveRange;
            const size = gameStateRef.current.gridSize;
            for (let x = 0; x < size; x++) {
              for (let y = 0; y < size; y++) {
                if (getDistance({x, y}, unit) <= range && getDistance({x,y}, unit) > 0) {
                  if (!units.some(u => u.x === x && u.y === y) && !bases.some(b => b.x === x && b.y === y)) moves.push({ x, y });
                }
              }
            }
            setValidMoves(moves);
            setValidTargets([]);
          };

          const prepareAttack = () => {
            const unit = units.find(u => u.id === selectedUnitId);
            if (!unit) return;
            if(audioEnabled) playSound('ui_click');
            setIsAttacking(true);
            setValidMoves([]);
            const targets = [];
            const adjs = [{x: unit.x+1, y: unit.y}, {x: unit.x-1, y: unit.y}, {x: unit.x, y: unit.y+1}, {x: unit.x, y: unit.y-1}];
            adjs.forEach(pos => {
              const eu = units.find(u => u.x === pos.x && u.y === pos.y && u.owner !== turn && !u.buffs?.stealth);
              if (eu) targets.push({ type: 'UNIT', id: eu.id, x: pos.x, y: pos.y });
              const eb = bases.find(b => b.x === pos.x && b.y === pos.y && b.owner !== turn);
              if (eb && players[eb.owner].isAlive) targets.push({ type: 'BASE', id: eb.id, x: pos.x, y: pos.y });
            });
            setValidTargets(targets);
            if (targets.length === 0) { addLog('ÁõÆÊ®ôËÑ´Èõ¢ÁØÑÂúç'); if(audioEnabled) playSound('error'); setIsAttacking(false); }
          };

          const handleCellClick = (x, y) => {
            if (gameOver || isBotThinking || view !== 'GAME') return;
            if (!canControl()) return; 

            if (selectedCard) {
                const t = validTargets.find(v => v.x === x && v.y === y);
                if (t) handleCardTargetClick(t); 
                else if (selectedCard.card.effect !== 'BUFF_HP' && selectedCard.card.effect !== 'BUFF_STEALTH') { setSelectedCard(null); setValidTargets([]); } 
                return;
            }
            if (isAttacking) {
              const t = validTargets.find(v => v.x === x && v.y === y);
              if (t) { performAttack(selectedUnitId, t.id, t.type); resetSelection(); } 
              else { setIsAttacking(false); setValidTargets([]); if(audioEnabled) playSound('ui_cancel'); }
              return;
            }
            const move = validMoves.find(m => m.x === x && m.y === y);
            if (move && !selectedCard) { performMove(selectedUnitId, x, y); resetSelection(); return; }
            const unit = units.find(u => u.x === x && u.y === y);
            if (unit) { handleSelectUnit(unit); return; }
            if (selectedUnitId) { resetSelection(); if(audioEnabled) playSound('ui_cancel'); }
          };

          const resetSelection = () => { setSelectedUnitId(null); setValidMoves([]); setIsAttacking(false); };

          const handleAskStrategy = async () => {
            if (isAiAdvising || gameOver) return;
            setIsAiAdvising(true);
            if(audioEnabled) playSound('ui_click');
            setAiAdvice("ÊéÉÊèèÊà∞Â†¥Êï∏Êìö...");
            const advice = await callGemini(`Êà∞Ê£ãËªçÂ∏´ÔºåÊàëÊñπ(Á¥Ö)Ââ© ${units.filter(u=>u.owner===0).length} ÂñÆ‰ΩçÔºåÁµ¶ÂÄãÁ∞°Áü≠Êà∞Ë°ìÂª∫Ë≠∞(20Â≠óÂÖßÁπÅ‰∏≠)`);
            setAiAdvice(advice || "ÈÄöË®ä‰∏≠Êñ∑");
            setIsAiAdvising(false);
          };

          const renderCell = (x, y) => {
            const base = bases.find(b => b.x === x && b.y === y);
            const unit = units.find(u => u.x === x && u.y === y);
            const item = items.find(i => i.x === x && i.y === y);
            const isSelected = unit && unit.id === selectedUnitId;
            const isValidMove = validMoves.some(m => m.x === x && m.y === y);
            const isValidTarget = validTargets.some(t => t.x === x && t.y === y);
            const isHidden = unit && unit.owner !== myPlayerId && unit.buffs?.stealth; 
            const unitToRender = isHidden ? null : unit;

            let bgColor = 'bg-slate-900/80';
            if (base) bgColor = PLAYERS[base.owner].baseBg;
            if (isValidMove) bgColor = 'bg-cyan-500/20 shadow-[inset_0_0_10px_rgba(6,182,212,0.5)] cursor-pointer';
            if (isValidTarget) bgColor = 'bg-rose-500/30 shadow-[inset_0_0_15px_rgba(244,63,94,0.6)] cursor-pointer animate-pulse';

            let hpBar = null;
            if (unitToRender) {
                const baseHp = UNIT_TYPES[unitToRender.type].hp;
                const hpPercent = Math.min(100, (unitToRender.hp / baseHp) * 100);
                const shieldPercent = unitToRender.hp > baseHp ? ((unitToRender.hp - baseHp) / baseHp) * 100 : 0;
                hpBar = (
                     <div className="w-9 h-1 bg-slate-800 mt-1 rounded-full border border-slate-600 overflow-hidden relative">
                        <div className={`h-full absolute top-0 left-0 transition-all ${unitToRender.hp <= 2 ? 'bg-red-500' : 'bg-green-400'}`} style={{ width: `${hpPercent}%` }}/>
                        {shieldPercent > 0 && <div className="h-full absolute top-0 left-0 bg-cyan-400/80 shadow-[0_0_5px_rgba(34,211,238,0.8)]" style={{ width: `${Math.min(100, shieldPercent)}%` }}/>}
                    </div>
                );
            }

            return (
              <div key={`${x}-${y}`} onClick={() => handleCellClick(x, y)} className={`w-full aspect-square border border-slate-700/50 relative flex items-center justify-center ${bgColor} transition-all duration-300 backdrop-blur-sm`}>
                <div className="absolute top-0 left-0 w-1 h-1 bg-slate-600/30"></div>
                <div className="absolute bottom-0 right-0 w-1 h-1 bg-slate-600/30"></div>
                {base && base.hp > 0 && (<div className="absolute inset-0 flex flex-col items-center justify-center opacity-40 pointer-events-none"><Castle className={PLAYERS[base.owner].text} size={28} /></div>)}
                {base && <div className="absolute top-0 right-0 text-[10px] font-bold text-slate-400 p-1 font-mono">{Math.max(0, base.hp)}</div>}
                {item && !unitToRender && (<div className="relative"><div className="absolute -inset-2 bg-yellow-400/30 blur-md rounded-full animate-pulse"></div><Zap className="text-yellow-400 relative z-10" size={20} /></div>)}
                {unitToRender && (
                  <div className={`relative z-10 flex flex-col items-center transition-all duration-300 ${isSelected ? 'scale-110 -translate-y-1' : ''} ${unitToRender.hasActed ? 'opacity-60 grayscale' : ''} ${unitToRender.buffs?.stealth ? 'opacity-40 animate-pulse' : ''}`}>
                    {unitToRender.buffs?.doubleDamage && <div className="absolute -top-4 text-orange-500 animate-bounce"><Flame size={14}/></div>}
                    {unitToRender.buffs?.stealth && <div className="absolute -top-4 left-4 text-cyan-400 animate-pulse"><Ghost size={12}/></div>}
                    <div className={`w-9 h-9 rounded-xl flex items-center justify-center shadow-lg border-2 ${PLAYERS[unitToRender.owner].color} ${PLAYERS[unitToRender.owner].border} text-white ${isSelected ? 'ring-2 ring-white shadow-cyan-500' : ''}`}>
                      {unitToRender.type === 'WARRIOR' && <Sword size={18} />}
                      {unitToRender.type === 'SCOUT' && <Eye size={18} />}
                      {unitToRender.type === 'ASSASSIN' && <Ghost size={18} />}
                    </div>
                    {hpBar}
                  </div>
                )}
                {isValidMove && !unitToRender && <div className="w-2 h-2 bg-cyan-400 rounded-full animate-ping"></div>}
              </div>
            );
          };

          if (view === 'MENU') {
              return (
                  <div className="min-h-screen bg-black text-slate-100 flex flex-col items-center justify-center p-4 relative overflow-hidden font-mono text-center">
                      <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 via-black to-black opacity-80"></div>
                      <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px)', backgroundSize: '40px 40px'}}></div>
                      <div className="z-10 space-y-8 animate-in fade-in zoom-in duration-700 w-full max-w-md">
                          <div className="relative inline-block"><Castle size={80} className="text-cyan-400 relative z-10" /></div>
                          <div className="space-y-2"><h1 className="text-5xl md:text-7xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-500">ÂõõÂúãÊà∞Ê£ã</h1><p className="text-cyan-200/60 text-lg tracking-[0.5em] uppercase font-bold">Cyber Tactics</p></div>
                          
                          {!peerRef.current || !myPeerId ? (
                            <div className="flex flex-col gap-4 mx-auto w-full">
                                <div className="flex bg-slate-800/50 p-1 rounded-lg border border-slate-700 mb-2">
                                    <button onClick={() => setSelectedMode('STANDARD')} className={`flex-1 py-2 text-sm font-bold rounded transition-all ${selectedMode === 'STANDARD' ? 'bg-cyan-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}>
                                        Ê®ôÊ∫ñÊà∞ÂΩπ (8x8)
                                    </button>
                                    <button onClick={() => setSelectedMode('ASSASSIN')} className={`flex-1 py-2 text-sm font-bold rounded transition-all ${selectedMode === 'ASSASSIN' ? 'bg-purple-600 text-white shadow-lg' : 'text-slate-400 hover:text-white'}`}>
                                        Âà∫ÂÆ¢Ê®°Âºè (10x10)
                                    </button>
                                </div>

                                <button onClick={() => { setIsMultiplayer(false); initGame(selectedMode); }} className={`group px-8 py-4 bg-slate-800/50 border border-slate-600 hover:bg-slate-700 transform skew-x-[-10deg] transition-all font-bold text-lg flex items-center justify-center gap-3 ${selectedMode === 'ASSASSIN' ? 'text-purple-100 border-purple-500/30' : 'text-cyan-100 border-cyan-500/30'}`}><Play className="transform skew-x-[10deg]"/> <span className="transform skew-x-[10deg]">ÂñÆ‰∫∫Êà∞ÂΩπ (Single)</span></button>
                                <button onClick={() => { setIsMultiplayer(true); startMultiplayer('HOST', selectedMode); }} className="group px-8 py-4 bg-orange-600/20 border border-orange-500/50 hover:bg-orange-500/40 transform skew-x-[-10deg] transition-all font-bold text-lg text-orange-100 flex items-center justify-center gap-3"><Wifi className="transform skew-x-[10deg]"/> <span className="transform skew-x-[10deg]">Âª∫Á´ãÊàøÈñì (Host)</span></button>
                                <button onClick={() => { setIsMultiplayer(true); startMultiplayer('CLIENT', null); }} className="group px-8 py-4 bg-blue-600/20 border border-blue-500/50 hover:bg-blue-500/40 transform skew-x-[-10deg] transition-all font-bold text-lg text-blue-100 flex items-center justify-center gap-3"><Link className="transform skew-x-[10deg]"/> <span className="transform skew-x-[10deg]">Âä†ÂÖ•ÊàøÈñì (Join)</span></button>
                                
                                <div className="flex gap-2 justify-center mt-4">
                                    <button onClick={() => setView('RULES')} className="px-6 py-2 bg-slate-800 border border-slate-700 rounded text-slate-300 hover:text-white text-sm">Ë¶èÂâáË™™Êòé</button>
                                    <button onClick={() => setAudioEnabled(!audioEnabled)} className="px-6 py-2 bg-slate-800 border border-slate-700 rounded text-slate-300 hover:text-white text-sm flex items-center gap-2">{audioEnabled ? <Volume2 size={16}/> : <VolumeX size={16}/>} Èü≥Êïà</button>
                                </div>
                            </div>
                          ) : (
                            <div className="glass-panel p-6 rounded-xl space-y-4 text-left animate-in slide-in-from-bottom">
                                <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                    {isHost ? <Wifi className="text-green-400"/> : <Link className="text-blue-400"/>}
                                    {isHost ? 'Á≠âÂæÖÂ∞çÊâãÈÄ£Á∑ö...' : 'Ëº∏ÂÖ•ÊàøËôüÂä†ÂÖ•'}
                                </h3>
                                
                                {isHost ? (
                                    <div className="space-y-4">
                                        <div className="bg-black/50 p-4 rounded border border-slate-700 flex flex-col gap-2">
                                            <span className="text-slate-400 text-xs uppercase tracking-widest">ÊÇ®ÁöÑÊàøÈñì ID</span>
                                            <div className="flex items-center gap-2">
                                                <code className="text-2xl font-mono text-cyan-400 flex-1 overflow-hidden">{myPeerId || 'ÁîüÊàê‰∏≠...'}</code>
                                                <button onClick={() => {navigator.clipboard.writeText(myPeerId); addLog('Â∑≤Ë§áË£Ω ID')}} className="p-2 hover:bg-slate-700 rounded"><Copy size={18}/></button>
                                            </div>
                                        </div>
                                        <div className="text-center text-sm text-slate-500 animate-pulse">
                                            ÁõÆÂâçÊ®°ÂºèÔºö<span className="text-white font-bold">{selectedMode === 'STANDARD' ? 'Ê®ôÊ∫ñ (8x8)' : 'Âà∫ÂÆ¢ (10x10)'}</span>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        <input type="text" placeholder="Ë≤º‰∏äÊàø‰∏ª ID" value={connectToId} onChange={(e) => setConnectToId(e.target.value)} className="w-full bg-slate-900 border border-slate-700 p-3 rounded text-white focus:border-cyan-500 outline-none font-mono"/>
                                        <button onClick={joinGame} disabled={connectionStatus !== 'CONNECTING'} className="w-full py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded flex items-center justify-center gap-2">
                                            {connectionStatus === 'CONNECTING' ? 'ÈÄ£Á∑ö‰∏≠...' : 'ÈñãÂßãÈÄ£Á∑ö'} <RotateCcw size={16}/>
                                        </button>
                                    </div>
                                )}
                                <button onClick={() => window.location.reload()} className="w-full py-2 text-slate-500 hover:text-white text-sm">ÂèñÊ∂àËøîÂõû</button>
                            </div>
                          )}
                      </div>
                  </div>
              );
          }

          if (view === 'RULES') {
              return (
                  <div className="min-h-screen bg-slate-950 text-slate-100 flex flex-col p-4 md:p-8 font-sans overflow-y-auto scroll-smooth">
                      <div className="max-w-4xl mx-auto w-full space-y-6 animate-in slide-in-from-right duration-500">
                          <button onClick={() => { setView('MENU'); if(audioEnabled) playSound('ui_cancel'); }} className="flex items-center gap-2 text-cyan-400 hover:text-cyan-300 transition-colors font-bold tracking-wider sticky top-0 bg-slate-950/90 py-2 z-10 backdrop-blur"><ChevronLeft /> ËøîÂõû‰∏ªÈÅ∏ÂñÆ</button>
                          <div className="glass-panel rounded-2xl p-6 md:p-10 shadow-2xl">
                              <h2 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-10 flex items-center gap-4 border-b border-slate-700 pb-6"><ScrollText className="text-cyan-500 w-10 h-10" /> Êà∞Ë°ì‰ΩúÊà∞ÊåáÂçó</h2>
                              <div className="space-y-12 text-slate-300">
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-4 flex items-center gap-3"><span className="p-2 bg-red-500/20 rounded-lg text-red-400"><User size={24}/></span> 1. ‰ΩúÊà∞ÁõÆÊ®ô & ÈÄ£Á∑öË¶èÂâá</h3>
                                      <div className="pl-4 border-l-2 border-slate-700 space-y-3">
                                          <p className="text-lg">ÊåáÊèÆÂÆòÔºå‰Ω†ÁöÑ‰ªªÂãôÊòØÂ≠òÊ¥ªÂà∞ÊúÄÂæå„ÄÇ</p>
                                          <div className="grid md:grid-cols-2 gap-4 mt-4">
                                              <div className="bg-slate-800/60 p-4 rounded-lg border border-slate-700"><div className="text-yellow-400 font-bold mb-1">üëë ÂãùÂà©Ê¢ù‰ª∂</div>ÊàêÁÇ∫Êà∞Â†¥‰∏ä <span className="text-white">ÂîØ‰∏ÄÂ≠òÊ¥ª</span> ÁöÑÈô£Ááü„ÄÇ</div>
                                              <div className="bg-slate-800/60 p-4 rounded-lg border border-slate-700"><div className="text-red-400 font-bold mb-1">üíÄ Â§±ÊïóÊ¢ù‰ª∂</div>ÊàëÊñπ <span className="text-white">Â§ßÊú¨Ááü HP Ê≠∏Èõ∂</span>„ÄÇ</div>
                                          </div>
                                          <div className="mt-4 p-4 bg-cyan-900/20 border border-cyan-800 rounded-lg">
                                              <h4 className="font-bold text-cyan-400 flex gap-2 items-center"><Wifi size={16}/> ÈÄ£Á∑öÊ®°ÂºèË™™Êòé</h4>
                                              <ul className="text-sm space-y-1 mt-2 text-slate-300">
                                                  <li>‚Ä¢ <span className="text-white font-bold">Host (Êàø‰∏ª)</span>ÔºöÊâÆÊºîÁ¥ÖÈöäÔºåË≤†Ë≤¨ÈÅãÁÆóÁ∂†ÈöäËàáÈªÉÈöä AI„ÄÇ</li>
                                                  <li>‚Ä¢ <span className="text-white font-bold">Client (ÂÆ¢Á´Ø)</span>ÔºöÊâÆÊºîËóçÈöä„ÄÇ</li>
                                                  <li>‚Ä¢ Ëã•Êàø‰∏ªÈÅ∏Êìá„ÄåÂà∫ÂÆ¢Ê®°Âºè„ÄçÔºåÂÆ¢Á´ØÂä†ÂÖ•ÊôÇÂ∞áËá™ÂãïÂàáÊèõÁÇ∫Âà∫ÂÆ¢Ê®°Âºè‰ªãÈù¢„ÄÇ</li>
                                              </ul>
                                          </div>
                                      </div>
                                  </section>
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-6 flex items-center gap-3"><span className="p-2 bg-blue-500/20 rounded-lg text-blue-400"><Sword size={24}/></span> 2. Êà∞È¨•ÂñÆ‰ΩçÊï∏ÊìöÂ∫´</h3>
                                      <div className="grid lg:grid-cols-3 gap-6">
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-red-500/50 transition-colors">
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-red-900/50 rounded text-red-400"><Sword size={24}/></div><div><div className="font-black text-xl text-white">Êà∞Â£´ (Warrior)</div><div className="text-xs text-slate-500">‰∏ªÂäõËº∏Âá∫ / Âù¶ÂÖã</div></div></div>
                                              <ul className="text-sm space-y-2"><li>‚ù§Ô∏è ÁîüÂëΩÂÄºÔºö<span className="text-green-400 font-mono text-lg">6</span></li><li>‚öîÔ∏è ÊîªÊìäÂäõÔºö<span className="text-red-400 font-mono text-lg">3</span></li><li>ü¶∂ ÁßªÂãïÂäõÔºö<span className="text-blue-400 font-mono text-lg">2 Ê†º</span></li></ul>
                                          </div>
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-blue-500/50 transition-colors">
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-blue-900/50 rounded text-blue-400"><Eye size={24}/></div><div><div className="font-black text-xl text-white">ÂÅµÊü•ÂÖµ (Scout)</div><div className="text-xs text-slate-500">Ë≥áÊ∫êÊî∂ÈõÜ / Âø´ÈÄü</div></div></div>
                                              <ul className="text-sm space-y-2"><li>‚ù§Ô∏è ÁîüÂëΩÂÄºÔºö<span className="text-green-400 font-mono text-lg">3</span></li><li>‚öîÔ∏è ÊîªÊìäÂäõÔºö<span className="text-slate-500 font-mono">ÁÑ°Ê≥ïÊîªÊìä</span></li><li>ü¶∂ ÁßªÂãïÂäõÔºö<span className="text-blue-400 font-mono text-lg">2 Ê†º</span></li><li className="text-cyan-300 mt-2 text-xs">Áî®ÈÄîÔºö‰ΩîÈ†òÊ©üÈÅáÂç° <Zap size={10} className="inline"/>„ÄÇ</li></ul>
                                          </div>
                                          <div className="bg-slate-800/50 p-5 rounded-xl border border-slate-700 hover:border-purple-500/50 transition-colors relative overflow-hidden">
                                              <div className="absolute top-0 right-0 bg-purple-600 text-white text-[10px] px-2 py-1 rounded-bl font-bold">Âà∫ÂÆ¢Ê®°ÂºèÈôêÂÆö</div>
                                              <div className="flex items-center gap-3 mb-4 border-b border-slate-700 pb-3"><div className="p-2 bg-purple-900/50 rounded text-purple-400"><Ghost size={24}/></div><div><div className="font-black text-xl text-white">Âà∫ÂÆ¢ (Assassin)</div><div className="text-xs text-slate-500">È´òÊ©üÂãï / Â•áË•≤</div></div></div>
                                              <ul className="text-sm space-y-2"><li>‚ù§Ô∏è ÁîüÂëΩÂÄºÔºö<span className="text-green-400 font-mono text-lg">4</span></li><li>‚öîÔ∏è ÊîªÊìäÂäõÔºö<span className="text-red-400 font-mono text-lg">2</span></li><li>ü¶∂ ÁßªÂãïÂäõÔºö<span className="text-blue-400 font-mono text-lg">3 Ê†º</span></li></ul>
                                          </div>
                                      </div>
                                  </section>
                                  <section>
                                      <h3 className="text-2xl font-bold text-white mb-6 flex items-center gap-3"><span className="p-2 bg-yellow-500/20 rounded-lg text-yellow-400"><Zap size={24}/></span> 3. Êà∞Ë°ìÊô∂Áâá (Ê©üÈÅáÂç°)</h3>
                                      <p className="mb-4 text-slate-400">ÂÅµÊü•ÂÖµË∏©Âà∞ÈñÉÈõªÊ†º <Zap size={14} className="inline text-yellow-400"/> ÂèØÁç≤ÂæóÔºåÈñãÂ±ÄÈö®Ê©ü 3 Âºµ„ÄÇ</p>
                                      <div className="grid md:grid-cols-2 gap-4">
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700"><div className="p-2 bg-green-900/50 text-green-400 rounded shrink-0"><Heart size={20}/></div><div><div className="font-bold text-green-300">ÊÄ•ÊïëÂåÖ</div><div className="text-xs text-slate-400">ÊÅ¢Âæ©ÂñÆ‰Ωç 3 HP„ÄÇ</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700"><div className="p-2 bg-red-900/50 text-red-400 rounded shrink-0"><Target size={20}/></div><div><div className="font-bold text-red-300">ÁãôÊìä</div><div className="text-xs text-slate-400">ÂÖ®ÂúñÊîªÊìäÊïµÊñπÂñÆ‰ΩçÈÄ†Êàê 2 ÂÇ∑ÂÆ≥„ÄÇ</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700"><div className="p-2 bg-blue-900/50 text-blue-400 rounded shrink-0"><Shield size={20}/></div><div><div className="font-bold text-blue-300">Âü∫Âú∞Ë≠∑Áõæ</div><div className="text-xs text-slate-400">‰øÆÂæ©Âü∫Âú∞ 5 HP (‰∏äÈôê15)„ÄÇ</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700"><div className="p-2 bg-orange-900/50 text-orange-400 rounded shrink-0"><Flame size={20}/></div><div><div className="font-bold text-orange-300">ÁãÇÊö¥ÈáùÂäë</div><div className="text-xs text-slate-400">Êà∞Â£´‰∏ã‰∏ÄÊ¨°ÊîªÊìä 2ÂÄçÂÇ∑ÂÆ≥„ÄÇ</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-slate-700"><div className="p-2 bg-cyan-900/50 text-cyan-400 rounded shrink-0"><Plus size={20}/></div><div><div className="font-bold text-cyan-300">ÂãïÂäõË£ùÁî≤</div><div className="text-xs text-slate-400">Êà∞Â£´Ê∞∏‰πÖ +4 HP‰∏äÈôê„ÄÇ</div></div></div>
                                          <div className="flex items-start gap-3 p-4 bg-slate-800/60 rounded-lg border border-purple-900/50"><div className="p-2 bg-purple-900/50 text-purple-400 rounded shrink-0"><VenetianMask size={20}/></div><div><div className="font-bold text-purple-300">Èö±ÂΩ¢Êä´È¢®</div><div className="text-xs text-slate-400">Âà∫ÂÆ¢Èö±Ë∫´ 1 ÂõûÂêà„ÄÇ</div></div></div>
                                      </div>
                                  </section>
                              </div>
                          </div>
                      </div>
                  </div>
              );
          }

          return (
            <div className="min-h-screen bg-slate-950 text-slate-100 flex flex-col font-sans select-none scroll-smooth">
              <header className="px-4 py-3 bg-slate-900/80 backdrop-blur border-b border-slate-800 flex justify-between items-center sticky top-0 z-30">
                <div className="flex items-center gap-3">
                   <button onClick={() => window.location.reload()} className="p-2 hover:bg-slate-800 rounded-lg text-slate-400 hover:text-white transition-colors"><ChevronLeft size={20}/></button>
                   <div>
                       <div className="text-[10px] text-slate-500 uppercase font-bold tracking-widest flex items-center gap-2">
                           Turn {round} 
                           {isMultiplayer && (isHost ? <span className="text-orange-400 px-1 border border-orange-500/30 rounded">HOST</span> : <span className="text-blue-400 px-1 border border-blue-500/30 rounded">CLIENT</span>)}
                           {!isMultiplayer && <span className="text-cyan-400 px-1 border border-cyan-500/30 rounded">SINGLE</span>}
                       </div>
                       <div className={`text-sm font-bold ${currentPlayer.text} flex items-center gap-2`}>
                           {currentPlayer.name} 
                           {currentPlayer.id === myPlayerId && <span className="text-[10px] bg-slate-700 text-white px-1.5 py-0.5 rounded-full">YOU</span>}
                       </div>
                   </div>
                </div>
                <div className="flex gap-2">
                    <button onClick={nextTurn} disabled={!canControl()} className={`px-4 py-1.5 rounded text-sm font-bold flex items-center gap-2 transition-all ${!canControl() ? 'bg-slate-800 text-slate-600 cursor-not-allowed' : 'bg-cyan-600 hover:bg-cyan-500'}`}>ÁµêÊùüÂõûÂêà <Footprints size={14}/></button>
                </div>
              </header>

              <main className="flex-1 flex flex-col md:flex-row relative">
                <div className="flex-1 flex items-center justify-center p-4 bg-black">
                   <div className="relative">
                     {/* ÈÄ£Á∑öÂêåÊ≠•‰∏≠ÁöÑÈÅÆÁΩ© */}
                     {isMultiplayer && !isHost && units.length === 0 && <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 text-white gap-4"><RefreshCw className="animate-spin text-cyan-400" size={40}/><div className="text-xl font-bold">Ê≠£Âú®ÂêåÊ≠•Êà∞Â†¥Êï∏Êìö...</div><div className="text-slate-500 text-sm">Ë´ãÁ®çÂÄôÔºåËã•ÈÅé‰πÖÁÑ°ÂõûÊáâË´ãÈáçÊï¥</div></div>}
                     
                     <div className="grid gap-1 bg-slate-900/90 p-2 rounded-lg border border-slate-700 shadow-2xl relative z-10" style={{ gridTemplateColumns: `repeat(${gridSize}, minmax(30px, 1fr))`, width: 'min(90vw, 85vh)', maxWidth: '650px' }}>
                       {Array.from({ length: gridSize }).map((_, y) => Array.from({ length: gridSize }).map((_, x) => renderCell(x, y)))}
                     </div>
                     {gameOver && (<div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-50 backdrop-blur rounded-lg border border-yellow-500/30"><h1 className="text-5xl font-black text-yellow-400 mb-6">GAME OVER</h1><button onClick={() => window.location.reload()} className="px-8 py-3 bg-white text-black font-bold flex items-center gap-2 rounded-lg">MENU</button></div>)}
                   </div>
                </div>

                <div className="md:w-96 bg-slate-900 border-t md:border-t-0 md:border-l border-slate-800 flex flex-col shadow-2xl z-20">
                    <div className="p-3 bg-slate-900/50 border-b border-slate-800 grid grid-cols-2 gap-2 text-xs">
                        {players.map(p => {
                            const getUnitStatus = (type) => {
                                const alive = units.find(u => u.owner === p.id && u.type === type);
                                if (alive) return `HP: ${alive.hp}`;
                                const dead = deadUnits.find(u => u.owner === p.id && u.type === type);
                                if (dead) return `Âæ©Ê¥ª: ${Math.max(1, dead.respawnRound - round)}T`;
                                return 'X';
                            };
                            return (
                                <div key={p.id} className={`p-2 rounded bg-slate-800/80 border ${p.isAlive ? 'border-slate-700 shadow-sm' : 'border-red-900/20 opacity-40'} ${p.id === myPlayerId ? 'ring-1 ring-cyan-500' : ''}`}>
                                    <div className={`font-bold ${p.text} mb-1 flex justify-between`}>{p.name} {p.id===myPlayerId && '‚òÖ'}</div>
                                    {p.isAlive ? (
                                        <div className="space-y-1">
                                            <div className="text-[10px] text-slate-400">Êà∞Â£´ {getUnitStatus('WARRIOR')}</div>
                                            <div className="text-[10px] text-slate-400">ÂÅµÊü• {getUnitStatus('SCOUT')}</div>
                                            {gameMode === 'ASSASSIN' && <div className="text-[10px] text-slate-400">Âà∫ÂÆ¢ {getUnitStatus('ASSASSIN')}</div>}
                                        </div>
                                    ) : <div className="text-slate-600 text-[10px] py-1">Èô£ÁáüÈô∑ËêΩ</div>}
                                </div>
                            );
                        })}
                    </div>

                    <div className="p-4 space-y-4">
                        {selectedUnit ? (
                            <div className="bg-slate-800/80 p-4 rounded-xl border border-slate-700 animate-in zoom-in-95">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-black text-white">{UNIT_TYPES[selectedUnit.type].name} (HP: {selectedUnit.hp})</span>
                                    <button onClick={resetSelection} className="text-slate-500"><X size={16}/></button>
                                </div>
                                {canControl() && !selectedUnit.hasActed && currentPlayer.id === selectedUnit.owner && (
                                    <button onClick={prepareAttack} className="w-full py-2.5 bg-red-500/10 text-red-400 border border-red-500/40 rounded-lg font-bold">‚öîÔ∏è ÁôºËµ∑ÊîªÊìä</button>
                                )}
                            </div>
                        ) : <div className="text-slate-700 text-center py-6 text-sm border-2 border-dashed border-slate-800 rounded-xl font-bold">{canControl() ? 'ÈªûÊìäÂñÆ‰ΩçÈÄ≤Ë°åÊìç‰Ωú' : (isMultiplayer && turn !== myPlayerId ? 'Á≠âÂæÖÂ∞çÊâãË°åÂãï...' : 'Á≠âÂæÖÈõªËÖ¶Ë°åÂãï...')}</div>}

                        {canControl() && currentPlayer.id === myPlayerId && (
                            <div className="mt-4">
                                <h3 className="text-[10px] font-black text-slate-500 uppercase tracking-widest mb-2">Êà∞Ë°ìÊô∂Áâá ({currentPlayer.cards.length})</h3>
                                <div className="grid gap-2">
                                    {currentPlayer.cards.map((card, idx) => (
                                        <button key={idx} onClick={() => startCardUse(card, idx)} className="flex items-center gap-3 p-3 rounded-lg border border-slate-800 bg-slate-800/30 hover:border-cyan-500/50 text-left w-full">
                                            <div className="p-2 bg-slate-950 rounded text-cyan-400"><card.icon size={16}/></div>
                                            <div><div className="font-bold text-xs text-slate-200">{card.name}</div><div className="text-[9px] text-slate-500">{card.desc}</div></div>
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}
                        <div className="h-20"></div> 
                    </div>
                </div>
              </main>
            </div>
          );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
